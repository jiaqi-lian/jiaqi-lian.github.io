<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>字符串最后一个单词长度</title>
    <link href="/2022/09/06/03-%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6/"/>
    <url>/2022/09/06/03-%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/e7f4b8a8a8254a9a978fedd4511a6e47.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count =<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(count) <br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span><br>                count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>代码</tag>
      
      <tag>牛客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编程题】给出两个整数n和k，返回从1到n中取k个数字的所有可能的组合</title>
    <link href="/2022/09/06/03-%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BB%99%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0n%E5%92%8Ck%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%BB%8E1%E5%88%B0n%E4%B8%AD%E5%8F%96k%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E7%BB%84%E5%90%88/"/>
    <url>/2022/09/06/03-%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BB%99%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0n%E5%92%8Ck%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%BB%8E1%E5%88%B0n%E4%B8%AD%E5%8F%96k%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/f3a68432c9df4673a51e15ef2dbc1c52.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @param k int整型 </span><br><span class="hljs-comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">1</span> || k&gt;n || k&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">findNum</span>(res,path,n,k,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res, vector&lt;<span class="hljs-type">int</span>&gt; &amp;path, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start; i&lt;=n; i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">findNum</span>(res, path, n, k, i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码</tag>
      
      <tag>牛客</tag>
      
      <tag>组合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编程题】得分最大</title>
    <link href="/2022/09/06/03-%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E5%BE%97%E5%88%86%E6%9C%80%E5%A4%A7/"/>
    <url>/2022/09/06/03-%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E5%BE%97%E5%88%86%E6%9C%80%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<p>牛牛和妞妞从他们的好朋友果果处得到了两个盒子，盒子里是一些写了分值的彩球。牛牛和妞妞发现两个盒子里的彩球数目是相等的，就决定一人一个。</p><p>妞妞拿到自己的盒子之后，决定跟牛牛玩一个游戏，规则如下：</p><p>一开始两个人盒子里的彩球数目都是n个，由妞妞先手，两人轮流实行下面两个操作中的一个（只能选其中一个执行，不能不执行。），直到两个盒子里的彩球都被拿完位置。</p><p>1、从自己的盒子里选一个球拿出来，把球上面的分值加在自己的总得分上边。<br>2、从对方的盒子里选一个球拿出来，把这个球移出游戏（对方不能再拿这个球）。</p><p>妞妞和牛牛都十分聪明，不会出错，并且尽可能让自己的得分比对方多。妞妞想知道，在游戏结束的时候，他能比牛牛多得多少分呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<br>第一行一个数字n，表示盒子里初始彩球的数目。<br>第二行n个数字ai，表示妞妞盒子里第i个彩球的分值是ai。<br>第三行n个数字bi，表示牛牛盒子里第i个彩球的分值是bi。<br>输出：<br>一个整数ans，表示游戏结束的时候妞妞比牛牛多的分值。<br><br><br>例子：<br>输入：<br>3<br>2 7 7<br>2 8 7<br>输出：<br>0<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;b)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    vector&lt;<span class="hljs-type">int</span>&gt; a, b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        <span class="hljs-type">int</span> t;<br>        cin&gt;&gt;t;<br>        a.<span class="hljs-built_in">push_back</span>(t);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        <span class="hljs-type">int</span> t;<br>        cin&gt;&gt;t;<br>        b.<span class="hljs-built_in">push_back</span>(t);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), cmp);<br>     <br>    <span class="hljs-type">int</span> ares=<span class="hljs-number">0</span>, bres=<span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator amax = a.<span class="hljs-built_in">begin</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator bmax = b.<span class="hljs-built_in">begin</span>();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">2</span>*n; i++)&#123;<br>      <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//A操作</span><br>         <span class="hljs-keyword">if</span>(amax != a.<span class="hljs-built_in">end</span>() &amp;&amp; bmax != b.<span class="hljs-built_in">end</span>())&#123;<br>             <span class="hljs-keyword">if</span>(*amax &lt; *bmax)&#123;<br>                 bmax++;<br>             &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*amax &gt;= *bmax)&#123;<br>                 ares += *amax;<br>                 amax++;&#125;<br>         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( amax == a.<span class="hljs-built_in">end</span>())&#123;<br>             bmax++;<br>         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bmax == b.<span class="hljs-built_in">end</span>())&#123;<br>             ares += *amax;<br>             amax++;<br>         &#125;<br>       &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//B操作</span><br>           <span class="hljs-keyword">if</span>(amax != a.<span class="hljs-built_in">end</span>() &amp;&amp; bmax != b.<span class="hljs-built_in">end</span>())&#123;<br>               <span class="hljs-keyword">if</span>(*amax &gt; *bmax)<br>                   amax++;<br>               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*amax &lt;= *bmax)&#123;<br>                   bres += *bmax;<br>                   bmax++;&#125;<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bmax == b.<span class="hljs-built_in">end</span>())<br>               amax++;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(amax == a.<span class="hljs-built_in">end</span>())&#123;<br>               bres += *bmax;<br>               bmax++;<br>           &#125;<br>          <br>       &#125;<br>       &#125;<br>    cout&lt;&lt;ares-bres&lt;&lt;endl;<br>     <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码</tag>
      
      <tag>牛客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【字符串】相关代码</title>
    <link href="/2022/09/06/03-%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%91%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/09/06/03-%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%91%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><code> 提示：这些是自己整理 可以借鉴 也可能存在错误 欢迎指正</code></p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p><strong>描述</strong></p><pre><code class="hljs">写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）</code></pre><p><strong>解题：</strong></p><ul><li>左右指针开始交换数据<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反转字符串</span><br><span class="hljs-comment">     * @param str string字符串 </span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">solve</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = str.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)<br>            <span class="hljs-built_in">swap</span>(str[left++], str[right--]);<br>        <span class="hljs-keyword">return</span> str;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h3 id="1-大数加法"><a href="#1-大数加法" class="headerlink" title="1.大数加法"></a>1.大数加法</h3><p><strong>描述</strong></p><pre><code class="hljs">以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。</code></pre><p>数据范围：s.length,t.length≤100000，字符串仅由’0’~‘9’构成<br>要求：时间复杂度 O(n)</p><p><strong>思路：</strong></p><ul><li>大整数相加，就可以按照整数相加的方式，从个位开始，逐渐往上累加，换到字符串中就是从两个字符串的末尾开始相加。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     * 计算两个数之和</span><br><span class="hljs-comment">     * @param s string字符串 表示第一个整数</span><br><span class="hljs-comment">     * @param t string字符串 表示第二个整数</span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">solve</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> t;<br>        <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-comment">//s记录比较大的数---保存结果</span><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">length</span>() &lt; t.<span class="hljs-built_in">length</span>())<br>            <span class="hljs-built_in">swap</span>(s, t);<br>        <span class="hljs-comment">//进位标志 flag</span><br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//从最后一位开始相加</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-type">int</span> temp = s[i] -<span class="hljs-string">&#x27;0&#x27;</span>+flag;<span class="hljs-comment">//转数字</span><br>            <span class="hljs-type">int</span> j = i-s.<span class="hljs-built_in">length</span>()+t.<span class="hljs-built_in">length</span>(); <span class="hljs-comment">//t的最后一位开始</span><br>            <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">0</span>)&#123;<br>                temp = temp + t[j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            flag = temp/<span class="hljs-number">10</span>;<br>            temp = temp % <span class="hljs-number">10</span>;<br>            s[i] = temp + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>)<br>            s = <span class="hljs-string">&#x27;1&#x27;</span> + s;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-最长公共子串"><a href="#2-最长公共子串" class="headerlink" title="2.最长公共子串"></a>2.最长公共子串</h3><p><strong>描述</strong></p><pre><code class="hljs">给定两个字符串str1和str2,输出两个字符串的最长公共子串题目保证str1和str2的最长公共子串存在且唯一。 </code></pre><p><strong>解题思路</strong></p><ul><li>动态规划</li><li>dp[i][j] &#x3D; dp[i-1][j-1] +1; else dp[i][j] &#x3D;0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * longest common substring</span><br><span class="hljs-comment">     * @param str1 string字符串 the string</span><br><span class="hljs-comment">     * @param str2 string字符串 the string</span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">LCS</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(str1.<span class="hljs-built_in">length</span>()+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(str2.<span class="hljs-built_in">length</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>, pos=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=str1.<span class="hljs-built_in">length</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=str2.<span class="hljs-built_in">length</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(str1[i<span class="hljs-number">-1</span>] == str2[j<span class="hljs-number">-1</span>])<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] +<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(dp[i][j] &gt; max)&#123;<br>                    max = dp[i][j];<br>                    pos = i<span class="hljs-number">-1</span>;<br>                &#125;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> str1.<span class="hljs-built_in">substr</span>(pos-max+<span class="hljs-number">1</span>, max);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-最长回文子串"><a href="#4-最长回文子串" class="headerlink" title="4. 最长回文子串"></a>4. 最长回文子串</h3><p><strong>描述</strong></p><pre><code class="hljs">对于长度为n的一个字符串A（仅包含数字，大小写英文字母），请设计一个高效算法，计算其中最长回文子串的长度。</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-string">&quot;ababc&quot;</span><br>返回值：3<br>说明：最长的回文子串为<span class="hljs-string">&quot;aba&quot;</span>与<span class="hljs-string">&quot;bab&quot;</span>，长度都为3  <br></code></pre></td></tr></table></figure><p><strong>解题思路：</strong><br><img src="https://img-blog.csdnimg.cn/366f68d1bee14569bdaf42fffdca16d4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6JG16Iqx5bm85YS_5Zut5Zut6ZW_,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param A string字符串 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLongestPalindrome</span><span class="hljs-params">(string A)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//最大长度</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//i为中心点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;A.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">helper</span>(A,i,i) &gt; <span class="hljs-built_in">helper</span>(A,i,i+<span class="hljs-number">1</span>))<br>                len = <span class="hljs-built_in">helper</span>(A,i,i);<br>            <span class="hljs-keyword">else</span><br>                len = <span class="hljs-built_in">helper</span>(A,i,i+<span class="hljs-number">1</span>);<br>            res = <span class="hljs-built_in">max</span>(res, len);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(string A, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-comment">//从左右开始扩散</span><br>        <span class="hljs-keyword">while</span>(left&gt;=<span class="hljs-number">0</span> &amp;&amp; right&lt;A.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(A[left] == A[right])&#123;<br>                left--;<br>                right++;<br>            &#125;<span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right-left+<span class="hljs-number">1</span><span class="hljs-number">-2</span>; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数组、矩阵】相关代码</title>
    <link href="/2022/09/06/03.%E3%80%90%E6%95%B0%E7%BB%84%E3%80%81%E7%9F%A9%E9%98%B5%E3%80%91%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/09/06/03.%E3%80%90%E6%95%B0%E7%BB%84%E3%80%81%E7%9F%A9%E9%98%B5%E3%80%91%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><strong>描述</strong></p><pre><code class="hljs">给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。（注：返回的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到）</code></pre><p><strong>解题思路：</strong></p><ul><li>两个for循环（缺点：超时）</li><li>哈希表&lt;取值， 下标&gt;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param numbers int整型vector </span><br><span class="hljs-comment">     * @param target int整型 </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> n = numbers.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; haxi;<span class="hljs-comment">//定义哈希表，&lt;取值，下标&gt;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(haxi.<span class="hljs-built_in">count</span>(target-numbers[i]))&#123; <span class="hljs-comment">//找到执行，没找到不执行</span><br>                res.<span class="hljs-built_in">push_back</span>(haxi[target-numbers[i]]+<span class="hljs-number">1</span>);<br>                res.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//将未找到的值插入哈希表中</span><br>                haxi[numbers[i]] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br><span class="hljs-comment">//        for(int i=0; i&lt;numbers.size()-1; i++)&#123;</span><br><span class="hljs-comment">//            for(int j=i+1; j&lt;numbers.size(); j++)&#123;</span><br><span class="hljs-comment">//                if(numbers[i] + numbers[j] == target)&#123;</span><br><span class="hljs-comment">//                    res.push_back(i+1);</span><br><span class="hljs-comment">//                    res.push_back(j+1);</span><br><span class="hljs-comment">//                    return res;</span><br><span class="hljs-comment">//                &#125;     </span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        return res;</span><br><span class="hljs-comment">//    &#125;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="合并两个有序的数组"><a href="#合并两个有序的数组" class="headerlink" title="合并两个有序的数组"></a>合并两个有序的数组</h3><p><strong>描述</strong></p><pre><code class="hljs">给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组</code></pre><p><strong>注意</strong></p><pre><code class="hljs">1.保证 A 数组有足够的空间存放 B 数组的元素， A 和 B 中初始的元素数目分别为 m 和 n，A的数组空间大小为 m+n2.不要返回合并的数组，将数组 B 的数据合并到 A 里面就好了，且后台会自动将合并后的数组 A 的内容打印出来，所以也不需要自己打印3. A 数组在[0,m-1]的范围也是有序的</code></pre><p><strong>思路：</strong></p><ul><li>step 1：使用三个指针，i指向数组A的最大元素，j指向数组B的最大元素，k指向数组A空间的结尾处。</li><li>step 2：从两个数组最大的元素开始遍历，直到某一个结束，每次取出较大的一个值放入数组A空间的最后，然后指针一次往前。</li><li>step 3：如果数组B先遍历结束，数组A前半部分已经存在了，不用管；但是如果数组A先遍历结束，则需要把数组B剩余的前半部分依次逆序加入数组A前半部分，类似归并排序最后的步骤。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> B[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = m<span class="hljs-number">-1</span>, j = n<span class="hljs-number">-1</span>, k = m+n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(A[i] &gt; B[j])<br>                A[k--] = A[i--];<br>            <span class="hljs-keyword">else</span><br>                A[k--] = B[j--];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span>)<br>                A[k--] = B[j--];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><p><strong>描述</strong></p><pre><code class="hljs">给定一个m x n大小的矩阵（m行，n列），按螺旋的顺序返回矩阵中的所有元素。</code></pre><p><img src="https://img-blog.csdnimg.cn/f8e2caa2df8a433281ffa4360edf058a.gif" alt="在这里插入图片描述"><br><strong>解题：</strong></p><ul><li>四个边界—上边界、下边界、左边界、右边界</li><li>直到边界重合</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">//左边界、右边界、上边界、下边界</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> down = n<span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-comment">//直到边界重合</span><br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= down)&#123;<br>            <span class="hljs-comment">//上边界从左到右</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=left; i&lt;=right; i++)<br>                res.<span class="hljs-built_in">push_back</span>(matrix[top][i]);<br>            top++;<br>            <span class="hljs-keyword">if</span>(top&gt;down)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//右边界从上到下</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=top; i&lt;= down; i++)<br>                res.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>            right--;<br>            <span class="hljs-keyword">if</span>(left&gt;right)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//下边界从右到左</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=right; i&gt;=left; i--)<br>                res.<span class="hljs-built_in">push_back</span>(matrix[down][i]);<br>            down--;<br>            <span class="hljs-keyword">if</span>(top&gt;down)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//左边界从下到上</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=down; i&gt;=top; i--)<br>                res.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>            left++;<br>            <span class="hljs-keyword">if</span>(left&gt;right)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p><img src="https://img-blog.csdnimg.cn/c7f5ffacdaea469fad2ef532987e59c1.png" alt="在这里插入图片描述"><br><strong>递归</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n== <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fibonacci</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">Fibonacci</span>(n<span class="hljs-number">-2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h3 id="最长无重复子数组"><a href="#最长无重复子数组" class="headerlink" title="最长无重复子数组"></a>最长无重复子数组</h3><p><strong>描述</strong></p><pre><code class="hljs">给定一个长度为n的数组arr，返回arr的最长无重复元素子数组的长度，无重复指的是所有数字都不相同。子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组</code></pre><p><strong>解题思路</strong></p><ul><li>step 1：构建一个哈希表，用于统计数组元素出现的次数。</li><li>step 2：窗口左右界都从数组首部开始，每次窗口优先右移右界，并统计进入窗口的元素的出现频率。</li><li>step 3：一旦右界元素出现频率大于1，就需要右移左界直到窗口内不再重复，将左边的元素移除窗口的时候同时需要将它在哈希表中的频率减1，保证哈希表中的频率都是窗口内的频率。</li><li>step 4：每轮循环，维护窗口长度最大值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param arr int整型vector the array</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <br>            <span class="hljs-comment">//右移进入哈希表统计出现次数</span><br>            mp[arr[i]]++;<br>            <span class="hljs-comment">//出现次数大于1，有重复</span><br>            <span class="hljs-keyword">while</span>(mp[arr[i]] &gt; <span class="hljs-number">1</span>)<br>                mp[arr[j++]]--;<br>            res = <span class="hljs-built_in">max</span>(res, i-j+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p><strong>描述</strong></p><pre><code class="hljs">给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。数据范围：0≤n≤3000，数组中各个元素值满足 ∣val∣≤100空间复杂度：O(n^2），时间复杂度 O(n^2)</code></pre><p><strong>注意：</strong></p><pre><code class="hljs">三元组（a、b、c）中的元素可以按任意顺序排列。解集中不能包含重复的三元组。输入：[-10,0,10,20,-10,-40]返回值：[[-10,-10,20],[-10,0,10]]</code></pre><p><strong>思路：</strong></p><ul><li>如果找到了某个数a，要找到与之对应的另外两个数，三数之和为0，等价于只要找到另外两个数之和为−a</li></ul><p><strong>具体做法：</strong></p><ul><li>step 1：排除<strong>边界</strong>特殊情况。</li><li>step 2：既然三元组内部要求非降序排列，那我们先得把这个无序的数组搞有序了，使用<strong>sort函数</strong>优先对其排序。</li><li>step 3：得到有序数组后，<strong>遍历该数组</strong>，对于每个遍历到的元素假设它是三元组中最小的一个，那么另外两个一定在后面。</li><li>step 4：需要三个数相加为0，则另外两个数相加应该为上述第一个数的相反数，我们可以利用<strong>双指针</strong>在剩余的子数组中找有没有这样的数对。双指针指向剩余子数组的首尾，如果二者相加为目标值，那么可以记录，而且二者中间的数字相加可能还会有。</li><li>step 5：如果二者相加大于目标值，说明右指针太大了，那就将其左移缩小，相反如果二者相加小于目标值，说明左指针太小了，将其右移扩大，直到两指针相遇，剩余子数组找完了。<br>注：对于三个数字都要判断是否相邻有重复的情况，要去重。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> x&lt;y;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;num) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> n = num.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">//对num排序</span><br>        <span class="hljs-built_in">sort</span>(num.<span class="hljs-built_in">begin</span>(), num.<span class="hljs-built_in">end</span>(),cmp);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n<span class="hljs-number">-2</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span> &amp;&amp; num[i] == num[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> left = i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = n<span class="hljs-number">-1</span>;<br>            <span class="hljs-type">int</span> target = -num[i]; <span class="hljs-comment">//两数相加为-num[i]</span><br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-keyword">if</span>(num[left] + num[right] == target)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;num[i], num[left], num[right]&#125;);<br>                    <span class="hljs-comment">//去重复</span><br>                    <span class="hljs-keyword">while</span>(left+<span class="hljs-number">1</span> &lt; right &amp;&amp; num[left] == num[left+<span class="hljs-number">1</span>])<br>                        left++;<br>                    <span class="hljs-keyword">while</span>(right<span class="hljs-number">-1</span> &gt; left &amp;&amp; num[right] == num[right<span class="hljs-number">-1</span>])<br>                        right--;<br>                    left++;<br>                    right--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num[left] + num[right] &gt; target)<br>                    right--;<br>                <span class="hljs-keyword">else</span><br>                    left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码</tag>
      
      <tag>数组</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【排序】相关代码</title>
    <link href="/2022/09/06/03.%E5%9F%BA%E4%BA%8E%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/09/06/03.%E5%9F%BA%E4%BA%8E%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><code> 提示：这些是自己整理 可以借鉴 也可能存在错误 欢迎指正</code></p><h1 id="基础排序"><a href="#基础排序" class="headerlink" title="基础排序"></a>基础排序</h1><p>经典排序：<a href="https://blog.csdn.net/weixin_44177594/article/details/124242591?spm=1001.2014.3001.5502">基础</a></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h3 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h3><p><strong>描述：</strong></p><pre><code class="hljs">给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。数据范围：0≤k,n≤10000，数组中每个数的大小0≤val≤1000    要求：空间复杂度O(n) ，时间复杂度 O(nlogn)</code></pre><p><strong>解题思路：</strong><br>    - 要求范围内的排序+输出<br>    - 可用排序（折半插入排序、快速排序）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; input, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">InsertSort</span>(input, input.<span class="hljs-built_in">size</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;k; i++)<br>            res.<span class="hljs-built_in">push_back</span>(input[i]);<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>    <br>    <span class="hljs-comment">//折半排序</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> low, mid, high;<br>        <span class="hljs-type">int</span> t;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)<br>        &#123;<br>            t = arr[i];<br>            low = <span class="hljs-number">0</span>;<br>            high = i<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>                mid = (low+high)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(arr[mid] &gt; t)<br>                    high = mid<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span> <br>                    low = mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>; j&gt;high; j--)&#123;<br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>            &#125;<br>            arr[low] = t;<br>        &#125;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="寻找第K大"><a href="#寻找第K大" class="headerlink" title="寻找第K大"></a>寻找第K大</h3><p><strong>描述</strong></p><pre><code class="hljs">有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)，保证答案存在。要求：时间复杂度 O(nlogn)，空间复杂度 O(1)</code></pre><p><strong>解题思路：</strong></p><pre><code class="hljs">- 1. 折半插入+输入（虽然结果正确但是不符合题意）- 2. 重载sort()函数，sort函数使用的是快速排序</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-comment">//InsertSort(a,n);</span><br>        <span class="hljs-keyword">return</span> a[n-K];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(a&lt;b)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> low, mid, high;<br>        <span class="hljs-type">int</span> t;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            t = arr[i];<br>            low = <span class="hljs-number">0</span>;<br>            high = i<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>                mid = (low+high)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(arr[mid] &gt; t)<br>                    high = mid<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span><br>                    low = mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>; j&gt;high; j--)&#123;<br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>            &#125;<br>            arr[low] = t;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【图】相关代码</title>
    <link href="/2022/09/06/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%90%E5%9B%BE%E3%80%91%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/09/06/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%90%E5%9B%BE%E3%80%91%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><h1 id="图的搜索"><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h1><h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><blockquote><p>思想：每次知道候选边中权值最小的边，并入生成树中（不能构成环—并查集）</p></blockquote><p><strong>执行过程：</strong>将图中边按照权值从小到大排序，然后从最小边开始扫描，并检测当前边是否为候选边，即是否该边的并入会构成回路。</p><pre><code class="hljs">并查集---使用数组存储（树的双亲存储结构）</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 返回最小的花费代价使得这n户人家连接起来</span><br><span class="hljs-comment">     * @param n int n户人家的村庄</span><br><span class="hljs-comment">     * @param m int m条路</span><br><span class="hljs-comment">     * @param cost intvector&lt;vector&lt;&gt;&gt; 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价</span><br><span class="hljs-comment">     * @return int</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; x, vector&lt;<span class="hljs-type">int</span>&gt;&amp; y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x[<span class="hljs-number">2</span>] &lt; y[<span class="hljs-number">2</span>];<br>    &#125;<span class="hljs-comment">//重载比较，按照边权递增</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; parent, <span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(parent[x] != x)<br>            parent[x] = <span class="hljs-built_in">find</span>(parent, parent[x]);<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<span class="hljs-comment">//找到最高的父亲</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">miniSpanningTree</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>            parent[i] = i;<br>        &#125;<span class="hljs-comment">//初始化，父亲设定为自己，每一颗树的根节点都是自己</span><br>        <span class="hljs-built_in">sort</span>(cost.<span class="hljs-built_in">begin</span>(), cost.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">//边权递增排序</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; cost.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-type">int</span> x = cost[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y = cost[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> z = cost[i][<span class="hljs-number">2</span>];<br>            <span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(parent, x); <span class="hljs-comment">//去找到x的根节点</span><br>            <span class="hljs-type">int</span> py = <span class="hljs-built_in">find</span>(parent, y); <span class="hljs-comment">//去找到y的根节点</span><br>            <span class="hljs-keyword">if</span>(px != py)&#123;<br>                res += z;<span class="hljs-comment">//，不构成环，边加入</span><br>                parent[px] = py; <span class="hljs-comment">//并入树中</span><br>            &#125;  <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//返回耗损</span><br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划相关代码</title>
    <link href="/2022/09/06/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/09/06/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><h3 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h3><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></blockquote><p><strong>递归</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(number &lt;= <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">jumpFloor</span>(number<span class="hljs-number">-1</span>)+<span class="hljs-built_in">jumpFloor</span>(number<span class="hljs-number">-2</span>);<br>        <span class="hljs-comment">//看做是从第n个台阶下台阶，f(n)</span><br>        <span class="hljs-comment">//有两种可能, 一个走一步，一个走两步，f(n) = f(n-1)+f(n-2);</span><br>        <span class="hljs-comment">//初始条件 f(0)=0, f(1)=1;</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>动态规划</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-type">int</span>  number)</span></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(number+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;=number; i++)<br>    &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[number];<br>    <span class="hljs-comment">//根据f[n] = f[n-1]+f[n-2];</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="连续子数组最大和"><a href="#连续子数组最大和" class="headerlink" title="连续子数组最大和"></a>连续子数组最大和</h3><p>给定一个长度为 n 的数组，数组中的数为整数。<br>请你选择一个非空连续子数组，使该子数组所有数之和尽可能大，子数组最小长度为1。求这个最大值。</p><pre><code class="hljs">    输入：8        1 -2 3 10 -4 7 2 -5    输出：18    说明：    经分析可知，输入数组的子数组[3,10,-4,7,2]可以求得最大和为18       </code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-comment">//输入</span><br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">val</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        cin&gt;&gt;t;<br>        val[i] = t;<br>    &#125;<br>    <br>    <span class="hljs-comment">//第i个数结尾的子数组最大连续和</span><br>    <span class="hljs-comment">//dp[i] = max(dp[i-1]+val[i], val[i])</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = val[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> res = dp[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>] + val[i], val[i]);<br>        res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>    &#125;<br>    <br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NOIP2001-装箱问题"><a href="#NOIP2001-装箱问题" class="headerlink" title="[NOIP2001]装箱问题"></a>[NOIP2001]装箱问题</h3><p>问题描述</p><pre><code class="hljs">有一个箱子容量为V（正整数，0 ≤ V ≤ 20000），同时有n个物品（0＜n ≤ 30），每个物品有一个体积（正整数）。要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。</code></pre><p>输入描述：</p><pre><code class="hljs">1个整数，表示箱子容量1个整数，表示有n个物品接下来n行，分别表示这n个物品的各自体积</code></pre><p>输出描述：</p><pre><code class="hljs">1个整数，表示箱子剩余空间</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//求背包的剩余空间最小=若干个物品的体积之和最大</span><br><span class="hljs-comment">//dp[i]:表示的是体积不超过i的放置方案的体积</span><br><span class="hljs-comment">//最小的剩余空间 = V-dp[v]</span><br><span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//输入</span><br>    <span class="hljs-type">int</span> v, n;<span class="hljs-comment">//v--体积，n--个数</span><br>    cin&gt;&gt;v&gt;&gt;n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ths</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        cin&gt;&gt;ths[i];<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">20001</span>)</span></span>;<br><br>    <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=v; j&gt;=ths[i]; j--) <span class="hljs-comment">//因为容量必须大于当前所放物品</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-ths[i]]+ths[i]);<span class="hljs-comment">//选还是不选，在有容量的同时保证放入最多</span><br>            <span class="hljs-comment">//dp[j] = min(dp[j], dp[j-ths[i]]);</span><br>        &#125;<br>    cout&lt;&lt;v-dp[v]&lt;&lt;endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>描述</p><pre><code class="hljs">你有一个背包，最多能容纳的体积是V。现在有n种物品，每种物品有任意多个，第i种物品的体积为v_i ,价值为w_i。（1）求这个背包至多能装多大价值的物品？（2）若背包恰好装满，求至多能装多大价值的物品？</code></pre><p><strong>每种物品有任意多个</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N];<span class="hljs-comment">//f[j]表示在体积j下的总价值</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-0x3f</span>, <span class="hljs-built_in">sizeof</span>(f));<br>    <br>    <span class="hljs-comment">//在可以加入多个相同物品时，使用正向</span><br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=m-v[i]; j++)&#123;<br>            <span class="hljs-keyword">if</span>(f[j] &gt;= <span class="hljs-number">0</span>)<br>                f[j+v[i]] = <span class="hljs-built_in">max</span>(f[j+v[i]], f[j]+w[i]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res1 = <span class="hljs-number">0</span>, res2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=m; i++)<br>        res1 = <span class="hljs-built_in">max</span>(res1, f[i]);<br>    cout&lt;&lt;res1&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">if</span>(f[m] &lt; <span class="hljs-number">0</span>)<br>        res2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        res2 = f[m];<br>    cout&lt;&lt;res2&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="买卖股票的最好时机-一"><a href="#买卖股票的最好时机-一" class="headerlink" title="买卖股票的最好时机(一)"></a>买卖股票的最好时机(一)</h3><p><strong>描述</strong></p><pre><code class="hljs">假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天2.如果不能获取到任何利润，请返回03.假设买入卖出均无手续费</code></pre><p><strong>解题：</strong></p><pre><code class="hljs">买卖股票有约束，根据题目意思，有以下两个约束条件：   条件 1：你不能在买入股票前卖出股票；条件 2：最多只允许完成一笔交易。因此 当天是否持股 是一个很重要的因素，而当前是否持股和昨天是否持股有关系，为此我们需要把 是否持股 设计到状态数组中</code></pre><p>状态定义：<br>dp[i][j]：下标为 i 这一天结束的时候，手上持股状态为 j 时，我们持有的现金数。<br>    j &#x3D; 0，表示当前不持股；<br>    j &#x3D; 1，表示当前持股。<br>注意：这个状态具有前缀性质，下标为 i 的这一天的计算结果包含了区间 [0, i] 所有的信息，因此最后输出 dp[len - 1][0]</p><p>不持股时：</p><ul><li>昨天不持股，今天什么都不干</li><li>昨天持股，今天卖出股票</li><li>持股时：</li><li>昨天持股，今天什么都不干</li><li>昨天不持股，今天买入</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param prices int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-comment">//低了买，高了卖</span><br>        <span class="hljs-comment">//找相差最大的一对</span><br>        <span class="hljs-comment">//贪婪算法，运行时间超出</span><br>        <span class="hljs-comment">//int res=0;</span><br>     <span class="hljs-comment">//for(int i=1; i&lt;prices.size(); i++)&#123;</span><br>     <span class="hljs-comment">//    for(int j=0; j&lt;i; j++)&#123;</span><br>     <span class="hljs-comment">//        if(prices[j] &lt; prices[i])&#123;</span><br>     <span class="hljs-comment">//            res = max(res, prices[i]-prices[j]);</span><br>     <span class="hljs-comment">//        &#125;</span><br>     <span class="hljs-comment">//    &#125;</span><br>     <span class="hljs-comment">//&#125;</span><br>     <span class="hljs-comment">//return res;</span><br>        <br>        <span class="hljs-comment">//动态规划</span><br>        <span class="hljs-type">int</span> len = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));<br>        <br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化：不持股为0，持股就需要减去第一天（下标为0）的股价</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<span class="hljs-comment">//持股，手上的现金数</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;len; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], -prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>        <br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h3 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h3><pre><code class="hljs">给定一个正三角形数组，自顶到底分别有 1，2，3，4，5...，n 个元素，找出自顶向下的最小路径和。每一步只能移动到下一行的相邻节点上，相邻节点指下行种下标与之相同或下标加一的两个节点。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//从下到上</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minTrace</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; triangle)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = triangle.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=i; j++)&#123;<br>                dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j+<span class="hljs-number">1</span>]) + triangle[i][j];<br>            &#125;       <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];  <br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//从上到下</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minTrace1</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; triangle)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = triangle.<span class="hljs-built_in">size</span>();<br>        <br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + triangle[i][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == i)<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + triangle[i][j];<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j]) + triangle[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res = INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n ; i++)<br>            res = <span class="hljs-built_in">min</span>(res, dp[n<span class="hljs-number">-1</span>][i]);<br>        <span class="hljs-keyword">return</span> res;  <br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="最长上升子序列-一"><a href="#最长上升子序列-一" class="headerlink" title="最长上升子序列(一)"></a>最长上升子序列(一)</h3><pre><code class="hljs">给定一个长度为 n 的数组 arr，求它的最长严格上升子序列的长度。</code></pre><p>所谓子序列，指一个数组删掉一些数（也可以不删）之后，形成的新数组。例如 [1,5,3,7,3] 数组，其子序列有：[1,3,3]、[7] 等。但 [1,6]、[1,3,5] 则不是它的子序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//输入</span><br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">val</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        cin&gt;&gt;val[i];<br>    <br>    <span class="hljs-comment">//dp数组保存每个数做结尾时对应的最大长度</span><br>    <span class="hljs-comment">//条件：val[i]&lt;val[j], dp[i]大于在j之前所有的dp中最大</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n ; i++)&#123;<br>        <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(val[j] &lt; val[i])<br>                mx = <span class="hljs-built_in">max</span>(mx, dp[j]);<br>        &#125;<br>        dp[i] = mx+<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = dp[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;dp.<span class="hljs-built_in">size</span>(); i++)<br>        res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列-一"><a href="#最长公共子序列-一" class="headerlink" title="最长公共子序列(一)"></a>最长公共子序列(一)</h3><pre><code class="hljs">给定两个字符串 s1 和 s2，长度为 n 和 m  。求两个字符串最长公共子序列的长度。</code></pre><p>所谓子序列，指一个字符串删掉部分字符（也可以不删）形成的字符串。例如：字符串 “arcaea” 的子序列有 “ara” 、 “rcaa” 等。但 “car” 、 “aaae” 则不是它的子序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    string s1, s2;<br>    cin&gt;&gt;s1&gt;&gt;s2;<br>    <br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;m; j++)&#123;<br>            <span class="hljs-keyword">if</span>(s1[i] == s2[j])<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i][j+<span class="hljs-number">1</span>], dp[i+<span class="hljs-number">1</span>][j]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][m]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长上升子序列-三"><a href="#最长上升子序列-三" class="headerlink" title="最长上升子序列(三)"></a>最长上升子序列(三)</h3><p><strong>描述</strong></p><pre><code class="hljs">给定数组 arr ，设长度为 n ，输出 arr 的最长上升子序列。（如果有多个答案，请输出其中 按数值(注：区别于按单个字符的ASCII码值)进行比较的 字典序最小的那个）</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * retrun the longest increasing subsequence</span><br><span class="hljs-comment">     * @param arr int整型vector the array</span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">LIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tail</span><span class="hljs-params">(n)</span></span>;<span class="hljs-comment">//希望末尾的数字越小越好</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<span class="hljs-comment">//第i个元素的最大递增子序列长度</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>, right=ans;<br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                <span class="hljs-type">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(tail[mid] &gt;= arr[i])<br>                    right = mid;<br>                <span class="hljs-keyword">else</span><br>                    left = mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            tail[left] = arr[i];<br>            dp[i] = left+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(left == ans)<br>                ans++;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(ans)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>, j=ans; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(dp[i] == j)<br>                res[--j] = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="模板-背包"><a href="#模板-背包" class="headerlink" title="[模板] 背包"></a>[模板] 背包</h3><p>描述</p><pre><code class="hljs">    你有一个背包，最多能容纳的体积是V。    现在有n个物品，第i个物品的体积为v_i,价值为w_i（1）求这个背包至多能装多大价值的物品？（2）若背包恰好装满，求至多能装多大价值的物品？</code></pre><p><img src="https://img-blog.csdnimg.cn/bf0945d1e109460c864a083a4fb76207.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6JG16Iqx5bm85YS_5Zut5Zut6ZW_,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//输入</span><br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> v[N], w[N];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    <br>    <span class="hljs-type">int</span> f[N];<span class="hljs-comment">//f[j]表示体积为j的情况下的总价值</span><br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-0x3f</span>, <span class="hljs-built_in">sizeof</span>(f));<br>    <br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//最开始体积为0价值为0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m; j&gt;=v[i]; j--)&#123;<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res1=<span class="hljs-number">0</span>, res2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=m; i++)<br>        res1 = <span class="hljs-built_in">max</span>(res1, f[i]);<br>    cout&lt;&lt;res1&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">if</span>(f[m]&lt;<span class="hljs-number">0</span>)<br>        res2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        res2 = f[m];<br>    cout&lt;&lt;res2&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础简单算法</title>
    <link href="/2022/09/06/03.%E5%9F%BA%E7%A1%80%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/"/>
    <url>/2022/09/06/03.%E5%9F%BA%E7%A1%80%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote><p>又叫折半查找</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param nums int整型vector </span><br><span class="hljs-comment">     * @param target int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//折半查找</span><br>        <span class="hljs-type">int</span> i, j, low, mid, high;<br>        low = <span class="hljs-number">0</span>, high =nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(low &lt;= high)<br>        &#123;<br>            mid = (low+high)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;target)<br>                high = mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)<br>                low = mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="求平方根"><a href="#求平方根" class="headerlink" title="求平方根"></a>求平方根</h3><p><strong>描述</strong></p><pre><code class="hljs">实现函数 int sqrt(int x).计算并返回 x 的平方根（向下取整）</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param x int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>, right=x, mid;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            mid=(left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(mid &lt;= (x/mid) &amp;&amp; (mid+<span class="hljs-number">1</span>) &gt; (x/(mid+<span class="hljs-number">1</span>)))<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(mid &gt; (x/mid))<br>                    right = mid<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span><br>                    left = mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树】相关基础代码</title>
    <link href="/2022/09/06/03.%E3%80%90%E6%A0%91%E3%80%91%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/09/06/03.%E3%80%90%E6%A0%91%E3%80%91%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p><strong>二叉树主要性质：</strong></p><ul><li>非空二叉树上叶子结点数等于双分支结点数加1。</li><li>二叉树的第i层上最多有$2^{i-1}(i≥1)$个结点。</li><li>高度（或深度）为k的二叉树最多有$2^k-1(k≥1)$个结点。换句话说，满二叉树中前k层的结点个数为$2^k-1$。</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h3><pre><code class="hljs">先序遍历1. 访问根节点2. 先序遍历左子树3. 先序遍历右子树</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-built_in">preorder</span>(root);<br>        <span class="hljs-keyword">return</span> t;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br><br>        t.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>        <span class="hljs-built_in">preorder</span>(p-&gt;left);<br>        <span class="hljs-built_in">preorder</span>(p-&gt;right);<br>        <br>    &#125;<br>   <br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>补充说明：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&lt;vector&gt;<span class="hljs-type">int</span> t;<br><span class="hljs-comment">//向量（Vector）是一个封装了动态大小数组的顺序容器.</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span></span><br><span class="hljs-function"><span class="hljs-comment">//向量尾部增加一个元素X.</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//删除向量中最后一个元素</span></span><br></code></pre></td></tr></table></figure><h3 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h3><pre><code class="hljs">中序遍历1. 先序遍历左子树2. 访问根节点3. 先序遍历右子树</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-built_in">inorder</span>(root);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inorder</span>(p-&gt;left);<br>        t.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>        <span class="hljs-built_in">inorder</span>(p-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h3><pre><code class="hljs">中序遍历1. 先序遍历左子树2. 先序遍历右子树3. 访问根节点</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-built_in">postorder</span>(root);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">postorder</span>(p-&gt;left);<br>        <span class="hljs-built_in">postorder</span>(p-&gt;right);<br>        t.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h3><blockquote><p>层次遍历、广度优先遍历<br>使用到队列结构</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; val;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> val;<br>        queue&lt;TreeNode*&gt; que;<br>        TreeNode* q;<br>        <br>        que.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">//根节点入队</span><br>        <br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; t;<br>            <span class="hljs-keyword">while</span>(size--)<br>            &#123;<br>                q = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//读取队首</span><br>                que.<span class="hljs-built_in">pop</span>();<br>                t.<span class="hljs-built_in">push_back</span>(q-&gt;val);<br>                <span class="hljs-keyword">if</span>(q-&gt;left != <span class="hljs-literal">NULL</span>)<br>                    que.<span class="hljs-built_in">push</span>(q-&gt;left);<br>                <span class="hljs-keyword">if</span>(q-&gt;right != <span class="hljs-literal">NULL</span>)<br>                    que.<span class="hljs-built_in">push</span>(q-&gt;right);             <br>            &#125;<br>            <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>)<br>                val.<span class="hljs-built_in">push_back</span>(t);         <br>        &#125;          <br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>补充知识—C++队列</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">empty</span>()               如果队列为空返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br>q.<span class="hljs-built_in">size</span>()                返回队列中元素的个数<br>q.<span class="hljs-built_in">pop</span>()                 删除队列首元素但不返回其值<br>q.<span class="hljs-built_in">front</span>()               返回队首元素的值，但不删除该元素<br>q.<span class="hljs-built_in">push</span>()                在队尾压入新元素<br>q.<span class="hljs-built_in">back</span>()                返回队列尾元素的值，但不删除该元素<br></code></pre></td></tr></table></figure><h3 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h3><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）</p><pre><code class="hljs">层次遍历+第一层从左到右，第二层从右到左，第三层从左到右在基础层次遍历的基础上+flag标识</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; val;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>        <span class="hljs-keyword">if</span>(pRoot == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> val;<br>        queue&lt;TreeNode*&gt; que;<br>        TreeNode* q;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        que.<span class="hljs-built_in">push</span>(pRoot); <span class="hljs-comment">//根节点入队</span><br>        <br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; t;<br>            <span class="hljs-keyword">while</span>(size--)<br>            &#123;<br>                q = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//读取队首</span><br>                que.<span class="hljs-built_in">pop</span>();<br>                t.<span class="hljs-built_in">push_back</span>(q-&gt;val);<br>                <span class="hljs-keyword">if</span>(q-&gt;left != <span class="hljs-literal">NULL</span>)<br>                    que.<span class="hljs-built_in">push</span>(q-&gt;left);<br>                <span class="hljs-keyword">if</span>(q-&gt;right != <span class="hljs-literal">NULL</span>)<br>                    que.<span class="hljs-built_in">push</span>(q-&gt;right);             <br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">reverse</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>)<br>                val.<span class="hljs-built_in">push_back</span>(t);  <br>            flag++;<br>        &#125;          <br>        <span class="hljs-keyword">return</span> val;<br>            <br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><blockquote><p>同样层次遍历；deep记录深度</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> deep=<span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        queue&lt;TreeNode*&gt; que;<br>        TreeNode* q;<br>        <br>        <br>        que.<span class="hljs-built_in">push</span>(root);<br>        <br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; t;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(size--)<br>            &#123;<br>                q = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                t.<span class="hljs-built_in">push_back</span>(q-&gt;val);<br>                <span class="hljs-keyword">if</span>(q-&gt;left != <span class="hljs-literal">NULL</span>)<br>                    que.<span class="hljs-built_in">push</span>(q-&gt;left);<br>                <span class="hljs-keyword">if</span>(q-&gt;right != <span class="hljs-literal">NULL</span>)<br>                    que.<span class="hljs-built_in">push</span>(q-&gt;right); <br>            &#125;<br>            <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>)<br>                deep++;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> deep;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉树中和为某一值的路径-一"><a href="#二叉树中和为某一值的路径-一" class="headerlink" title="二叉树中和为某一值的路径(一)"></a>二叉树中和为某一值的路径(一)</h3><pre><code class="hljs">给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。总节点数目为n</code></pre><ul><li>使用递归</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @param sum int整型 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        sum = sum - root-&gt;val;<br>        <span class="hljs-keyword">if</span>((root-&gt;left==<span class="hljs-literal">NULL</span>) &amp;&amp; (root-&gt;right==<span class="hljs-literal">NULL</span>))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span>) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, sum) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, sum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。<br><img src="https://img-blog.csdnimg.cn/3709b21d6db2410095283a2e99dd520f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6JG16Iqx5bm85YS_5Zut5Zut6ZW_,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><pre><code class="hljs"> 要求： 不能创建任何新的结点，只能调整树中结点指针的指向。 当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继 返回链表中的第一个节点的指针 </code></pre><p><strong>二叉线索树特点</strong>：左孩子结点小于根结点；右孩子结点大于根结点</p><p><strong>解题思路：采用二叉树中序递归遍历算法，再改变指针指向</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;TreeNode*&gt; res;<br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* p)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inorder</span>(p-&gt;left);<br>        res.<span class="hljs-built_in">emplace_back</span>(p);<br>        <span class="hljs-built_in">inorder</span>(p-&gt;right);     <br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Convert</span><span class="hljs-params">(TreeNode* pRootOfTree)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRootOfTree == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> pRootOfTree;<br>        <span class="hljs-built_in">inorder</span>(pRootOfTree);<br>        <span class="hljs-comment">//改变指针指向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i++)&#123;<br>            res[i]-&gt;right = res[i+<span class="hljs-number">1</span>];<br>            res[i+<span class="hljs-number">1</span>]-&gt;left = res[i]; <br>        &#125;<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h3><blockquote><p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）</p></blockquote><p><strong>递归</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetrical</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pRoot)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">help</span>(pRoot-&gt;left, pRoot-&gt;right);   <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">help</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>((!left &amp;&amp; right) || (left &amp;&amp; !right))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(!right &amp;&amp; !left)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(left-&gt;val != right-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">help</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="hljs-built_in">help</span>(left-&gt;right, right-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><p>已知两颗二叉树，将它们合并成一颗二叉树。<br>合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。</p><p><strong>递归</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param t1 TreeNode类 </span><br><span class="hljs-comment">     * @param t2 TreeNode类 </span><br><span class="hljs-comment">     * @return TreeNode类</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">NULL</span>)    <br>            <span class="hljs-keyword">return</span> t2;<br>        <span class="hljs-keyword">if</span>(t2 == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> t1;<br>        t1-&gt;val += t2-&gt;val;<br>        t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);<br>        t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);<br>        <span class="hljs-keyword">return</span> t1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br><strong>递归</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pRoot TreeNode类 </span><br><span class="hljs-comment">     * @return TreeNode类</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(!pRoot)<br>            <span class="hljs-keyword">return</span> pRoot;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">swap</span>&lt;TreeNode*&gt;(pRoot-&gt;left, pRoot-&gt;right);<br>            <span class="hljs-built_in">Mirror</span>(pRoot-&gt;left);<br>            <span class="hljs-built_in">Mirror</span>(pRoot-&gt;right); <br>        &#125;<br>        <span class="hljs-keyword">return</span> pRoot;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="判断是不是二叉搜索树"><a href="#判断是不是二叉搜索树" class="headerlink" title="判断是不是二叉搜索树"></a>判断是不是二叉搜索树</h3><p>给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树。</p><p>二叉搜索树满足每个节点的左子树上的所有节点均小于当前节点且右子树上的所有节点均大于当前节点。</p><pre><code class="hljs">使用中序遍历，判断中序遍历结果是不是递增的</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* p)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!p)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inorder</span>(p-&gt;left);<br>        t.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>        <span class="hljs-built_in">inorder</span>(p-&gt;right);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">inorder</span>(root);<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;t.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;)&#123;<br>            <span class="hljs-keyword">if</span>(t[i]&lt;t[i+<span class="hljs-number">1</span>])<br>                i++;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;         <br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == t.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="判断是不是完全二叉树"><a href="#判断是不是完全二叉树" class="headerlink" title="判断是不是完全二叉树"></a>判断是不是完全二叉树</h3><p>给定一个二叉树，确定他是否是一个完全二叉树。</p><p>完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）</p><p><strong>层次遍历</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCompleteTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        queue&lt;TreeNode*&gt; que;<br>        TreeNode* q;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(size--)<br>            &#123;<br>                q = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span> &amp;&amp; q != <span class="hljs-literal">NULL</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span>(q == <span class="hljs-literal">NULL</span>)<br>                    flag = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    que.<span class="hljs-built_in">push</span>(q-&gt;left);<br>                    que.<span class="hljs-built_in">push</span>(q-&gt;right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="判断是不是平衡二叉树"><a href="#判断是不是平衡二叉树" class="headerlink" title="判断是不是平衡二叉树"></a>判断是不是平衡二叉树</h3><p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。</p><p>平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><strong>递归</strong>—递归判断是不是平衡二叉树、递归计算子树高度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pRoot)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//求左右子树的高度</span><br>        <span class="hljs-type">int</span> leftHight = <span class="hljs-built_in">getHight</span>(pRoot-&gt;left), rightHight = <span class="hljs-built_in">getHight</span>(pRoot-&gt;right);<br>        <br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(leftHight - rightHight) &gt;<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">IsBalanced_Solution</span>(pRoot-&gt;left) &amp;&amp; <span class="hljs-built_in">IsBalanced_Solution</span>(pRoot-&gt;right);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHight</span><span class="hljs-params">(TreeNode* p)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!p)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//没有左右孩子---叶子结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHight</span>(p-&gt;left), <span class="hljs-built_in">getHight</span>(p-&gt;right));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><pre><code class="hljs">二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值</code></pre><p><strong>利用二叉搜索树的特性</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @param p int整型 </span><br><span class="hljs-comment">     * @param q int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        TreeNode* t = root;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p &lt; t-&gt;val &amp;&amp; q &lt; t-&gt;val)<br>                t = t-&gt;left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p &gt; t-&gt;val &amp;&amp; q &gt; t-&gt;val)<br>                t = t-&gt;right;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;                <br>        &#125;<br>        <span class="hljs-keyword">return</span> t-&gt;val;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="在二叉树中找到两个节点的最近公共祖先"><a href="#在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="在二叉树中找到两个节点的最近公共祖先"></a>在二叉树中找到两个节点的最近公共祖先</h3><p><strong>递归思想</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @param o1 int整型 </span><br><span class="hljs-comment">     * @param o2 int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">LCA</span><span class="hljs-params">(TreeNode* p, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(p-&gt;val == x || p-&gt;val == y)<br>            <span class="hljs-keyword">return</span> p;<br>        TreeNode* la = <span class="hljs-built_in">LCA</span>(p-&gt;left, x, y);<br>        TreeNode* ra = <span class="hljs-built_in">LCA</span>(p-&gt;right, x, y);<br>        <br>        <span class="hljs-keyword">if</span>(la == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> ra;<br>        <span class="hljs-keyword">if</span>(ra == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> la;<br>        <br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> o1, <span class="hljs-type">int</span> o2)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        TreeNode* lca = <span class="hljs-built_in">LCA</span>(root, o1, o2);<br>        <span class="hljs-keyword">return</span> lca-&gt;val;   <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉树根节点到叶子节点的所有路径和"><a href="#二叉树根节点到叶子节点的所有路径和" class="headerlink" title="二叉树根节点到叶子节点的所有路径和"></a>二叉树根节点到叶子节点的所有路径和</h3><p><img src="https://img-blog.csdnimg.cn/b497c772a4a54cbc83cab08d4a7e35ad.png" alt="在这里插入图片描述"><br><strong>递归</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">number</span>(root, num);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">number</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> num)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        num = num*<span class="hljs-number">10</span> + root-&gt;val;<br>        <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">number</span>(root-&gt;left, num)+<span class="hljs-built_in">number</span>(root-&gt;right, num);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><blockquote><p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。<br>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/c04342143ec24f35a1f37fb43ee38689.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for binary tree</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//前序和中序遍历序列构造二叉树</span><br>    <span class="hljs-comment">//pre 前序； vin 中序</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pre,vector&lt;<span class="hljs-type">int</span>&gt; vin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || vin.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(vin, <span class="hljs-number">0</span>, vin.<span class="hljs-built_in">size</span>(), pre, <span class="hljs-number">0</span>, pre.<span class="hljs-built_in">size</span>());<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ino, <span class="hljs-type">int</span> inb, <span class="hljs-type">int</span> ine, vector&lt;<span class="hljs-type">int</span>&gt; &amp;pre, <span class="hljs-type">int</span> preb, <span class="hljs-type">int</span> pree)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(preb == pree)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//结束</span><br>        <span class="hljs-type">int</span> rootval = pre[preb];<span class="hljs-comment">//前序序列的第一个表示根结点</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootval);<br>        <br>        <span class="hljs-keyword">if</span>(pree - preb == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <br>        <span class="hljs-type">int</span> del;<br>        <span class="hljs-keyword">for</span>(del = inb; del &lt; ine; del++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ino[del] == rootval)<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">//找到中序序列中的根节点所在地方，进行划分</span><br>        &#125;<br>        <br>        <span class="hljs-comment">//进行中序切割 左闭右开</span><br>        <span class="hljs-type">int</span> leftinb = inb, leftine = del;<br>        <span class="hljs-type">int</span> rightinb = del+<span class="hljs-number">1</span>, rightine = ine;<br>        <br>        <span class="hljs-comment">//进行前序切割 左闭右开</span><br>        <span class="hljs-type">int</span> leftpreb = preb+<span class="hljs-number">1</span>, leftpree = preb+<span class="hljs-number">1</span>+(del-inb);<br>        <span class="hljs-type">int</span> rightpreb = preb+<span class="hljs-number">1</span>+del-inb, rightpree = pree;<br>        <br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(ino, leftinb, leftine, pre, leftpreb, leftpree);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(ino, rightinb, rightine, pre, rightpreb, rightpree);<br>        <br>        <span class="hljs-keyword">return</span> root;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="输出二叉树的右视图"><a href="#输出二叉树的右视图" class="headerlink" title="输出二叉树的右视图"></a>输出二叉树的右视图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     * 求二叉树的右视图</span><br><span class="hljs-comment">     * @param xianxu int整型vector 先序遍历</span><br><span class="hljs-comment">     * @param zhongxu int整型vector 中序遍历</span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <br><span class="hljs-function">TreeNode* <span class="hljs-title">construct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pre,<span class="hljs-type">int</span> l1,<span class="hljs-type">int</span> r1,vector&lt;<span class="hljs-type">int</span>&gt; mid,<span class="hljs-type">int</span> l2,<span class="hljs-type">int</span> r2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(l1&gt;r1||l2&gt;r2) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pre[l1]);<br>        <span class="hljs-type">int</span> index=l2;<br>        <span class="hljs-keyword">for</span>(index;index&lt;=r2;index++)&#123;<br>            <span class="hljs-keyword">if</span>(mid[index]==pre[l1]) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        root-&gt;left=<span class="hljs-built_in">construct</span>(pre,l1+<span class="hljs-number">1</span>,l1+index-l2,mid,l2,index<span class="hljs-number">-1</span>);<br>        root-&gt;right=<span class="hljs-built_in">construct</span>(pre,l1+index-l2+<span class="hljs-number">1</span>,r1,mid,index+<span class="hljs-number">1</span>,r2);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; xianxu, vector&lt;<span class="hljs-type">int</span>&gt;&amp; zhongxu)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        TreeNode* root=<span class="hljs-built_in">construct</span>(xianxu,<span class="hljs-number">0</span>,xianxu.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,zhongxu,<span class="hljs-number">0</span>,zhongxu.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> size=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">while</span>(size--)&#123;<br>                TreeNode* node=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(flag)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                    flag=<span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                <span class="hljs-keyword">if</span>(node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>                        <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【栈、队列】相关代码</title>
    <link href="/2022/09/06/03.%E3%80%90%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%91%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/09/06/03.%E3%80%90%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%91%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><ul><li>栈是一种只能在一端进行插入或删除操作的线性表。</li><li>特点：先进后出</li><li>分类：顺序栈和链栈</li></ul><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="【模板】栈"><a href="#【模板】栈" class="headerlink" title="【模板】栈"></a>【模板】栈</h3><blockquote><p>定义、进栈、出栈</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> st[N];<br><span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>       <br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        string c;<br>        cin&gt;&gt;c;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&quot;push&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            st[++top] = x;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&quot;top&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(top == <span class="hljs-number">-1</span>)<br>                cout&lt;&lt;<span class="hljs-string">&quot;error&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cout&lt;&lt;st[top]&lt;&lt;endl;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&quot;pop&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(top == <span class="hljs-number">-1</span>)<br>                cout&lt;&lt;<span class="hljs-string">&quot;error&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cout&lt;&lt;st[top--]&lt;&lt;endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h3><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pushV,vector&lt;<span class="hljs-type">int</span>&gt; popV)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; data; <span class="hljs-comment">//构建栈</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pushV.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            data.<span class="hljs-built_in">push</span>(pushV[i]); <span class="hljs-comment">//进栈</span><br>            <span class="hljs-keyword">while</span>(data.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; popV[j] == data.<span class="hljs-built_in">top</span>())<br>            &#123;<br>                data.<span class="hljs-built_in">pop</span>();<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="有效括号序列"><a href="#有效括号序列" class="headerlink" title="有效括号序列"></a>有效括号序列</h3><blockquote><p>给出一个仅包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’,的字符串，判断给出的字符串是否是合法的括号序列</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param s string字符串 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        stack&lt;<span class="hljs-type">char</span>&gt; data;<br>        <br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>                data.<span class="hljs-built_in">push</span>(s[i]);<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) <br>                   data.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27;]&#x27;</span>) <br>                   data.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27;&#125;&#x27;</span>) <br>                   data.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <br>                    data.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h3><blockquote><p>给定一个逆波兰表达式，求表达式的值。</p></blockquote><p>逆波兰表达式和日常书写的表达式区别是符号会后置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param tokens string字符串vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; data;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;tokens.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tokens[i] != <span class="hljs-string">&quot;+&quot;</span> &amp;&amp; tokens[i] != <span class="hljs-string">&quot;-&quot;</span> &amp;&amp; tokens[i] != <span class="hljs-string">&quot;*&quot;</span> &amp;&amp; tokens[i] != <span class="hljs-string">&quot;/&quot;</span>)&#123;<br>                <br>                <span class="hljs-type">int</span> t = <span class="hljs-built_in">atoi</span>(tokens[i].<span class="hljs-built_in">c_str</span>());<span class="hljs-comment">//string--&gt;int</span><br>                data.<span class="hljs-built_in">push</span>(t);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">int</span> num = data.<span class="hljs-built_in">top</span>();<br>                data.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;+&quot;</span>)<br>                    data.<span class="hljs-built_in">top</span>() += num;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;-&quot;</span>)&#123;<br>                    data.<span class="hljs-built_in">top</span>() -= num;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;*&quot;</span>)&#123;<br>                    data.<span class="hljs-built_in">top</span>() *= num;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;/&quot;</span>)&#123;<br>                    data.<span class="hljs-built_in">top</span>() /= num;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="点击消除"><a href="#点击消除" class="headerlink" title="点击消除"></a>点击消除</h3><blockquote><p>牛牛拿到了一个字符串。<br>他每次“点击”，可以把字符串中相邻两个相同字母消除，例如，字符串”abbc”点击后可以生成”ac”。<br>但相同而不相邻、不相同的相邻字母都是不可以被消除的。<br>牛牛想把字符串变得尽可能短。他想知道，当他点击了足够多次之后，字符串的最终形态是什么？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string data;<br>    cin&gt;&gt;data;<br>    stack&lt;<span class="hljs-type">char</span>&gt; xc1;<br>    <span class="hljs-comment">//消除</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i: data)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!xc1.<span class="hljs-built_in">empty</span>() &amp;&amp; xc1.<span class="hljs-built_in">top</span>() == i)&#123;<br>            xc1.<span class="hljs-built_in">pop</span>();<br>        &#125;<span class="hljs-keyword">else</span><br>            xc1.<span class="hljs-built_in">push</span>(i);  <br>    &#125;<br>    <br>    <span class="hljs-comment">//读取</span><br>    stack&lt;<span class="hljs-type">char</span>&gt; xc2;<br>    <span class="hljs-keyword">while</span>(!xc1.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        xc2.<span class="hljs-built_in">push</span>(xc1.<span class="hljs-built_in">top</span>());<br>        xc1.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(xc2.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//输出</span><br>    <span class="hljs-keyword">while</span>(!xc2.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        cout&lt;&lt;xc2.<span class="hljs-built_in">top</span>();<br>        xc2.<span class="hljs-built_in">pop</span>();<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表达式求解"><a href="#表达式求解" class="headerlink" title="表达式求解"></a>表达式求解</h3><blockquote><p>请写一个整数计算器，支持加减乘三种运算和括号。<br>空间复杂度： O(n)，时间复杂度 O(n)</p></blockquote><p>两个栈、一个存放运算符、一个存放数值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     * 返回表达式的值</span><br><span class="hljs-comment">     * @param s string字符串 待计算的表达式</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; num;<span class="hljs-comment">//存放数值</span><br>        stack&lt;<span class="hljs-type">char</span>&gt; ops;<span class="hljs-comment">//存放运算符</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化计算值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>                sum = sum*<span class="hljs-number">10</span> +(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//大于10的数值</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(sum!=<span class="hljs-number">0</span>)<br>                &#123;<br>                    num.<span class="hljs-built_in">push</span>(sum);<span class="hljs-comment">//将数值入栈</span><br>                    sum = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(ops.<span class="hljs-built_in">empty</span>() || ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span> || s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                    ops.<span class="hljs-built_in">push</span>(s[i]);<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">while</span>(ops.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                            <span class="hljs-type">int</span> x = num.<span class="hljs-built_in">top</span>();<br>                            num.<span class="hljs-built_in">pop</span>();<br>                            <span class="hljs-type">int</span> y = num.<span class="hljs-built_in">top</span>();<br>                            num.<span class="hljs-built_in">pop</span>();<br>                            <span class="hljs-keyword">if</span>(ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;+&#x27;</span>)<br>                                num.<span class="hljs-built_in">push</span>(x+y);<br>                            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;-&#x27;</span>)<br>                                num.<span class="hljs-built_in">push</span>(y-x);<br>                            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                                num.<span class="hljs-built_in">push</span>(x*y);<br>                            ops.<span class="hljs-built_in">pop</span>();<br>                        &#125;<br>                        ops.<span class="hljs-built_in">pop</span>();<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">judge</span>(s[i], ops.<span class="hljs-built_in">top</span>()) == <span class="hljs-literal">false</span>)<br>                        &#123;<br>                            <span class="hljs-type">int</span> x = num.<span class="hljs-built_in">top</span>();<br>                            num.<span class="hljs-built_in">pop</span>();<br>                            <span class="hljs-type">int</span> y = num.<span class="hljs-built_in">top</span>();<br>                            num.<span class="hljs-built_in">pop</span>();<br>                            <span class="hljs-keyword">if</span>(ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;+&#x27;</span>)<br>                                num.<span class="hljs-built_in">push</span>(x+y);<br>                            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;-&#x27;</span>)<br>                                num.<span class="hljs-built_in">push</span>(y-x);<br>                            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                                num.<span class="hljs-built_in">push</span>(x*y);<br>                            ops.<span class="hljs-built_in">pop</span>();<br>                        &#125;<br>                        ops.<span class="hljs-built_in">push</span>(s[i]);<br>                    &#125;<br>                &#125;           <br>                    <br>            &#125;<br>        &#125;<br>            <br>       <span class="hljs-keyword">if</span>(sum!=<span class="hljs-number">0</span>)<br>       num.<span class="hljs-built_in">push</span>(sum);<br>       <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>())<br>       &#123;<br>           <span class="hljs-type">int</span> x = num.<span class="hljs-built_in">top</span>();<br>           num.<span class="hljs-built_in">pop</span>();<br>           <span class="hljs-type">int</span> y = num.<span class="hljs-built_in">top</span>();<br>           num.<span class="hljs-built_in">pop</span>();<br>           <span class="hljs-keyword">if</span>(ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;+&#x27;</span>)<br>               num.<span class="hljs-built_in">push</span>(x+y);<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;-&#x27;</span>)<br>               num.<span class="hljs-built_in">push</span>(y-x);<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;*&#x27;</span>)<br>               num.<span class="hljs-built_in">push</span>(x*y);<br>           ops.<span class="hljs-built_in">pop</span>();<br>       &#125;<br>        <span class="hljs-keyword">return</span> num.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">char</span> c1, <span class="hljs-type">char</span> c2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(c1 == <span class="hljs-string">&#x27;(&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c1 == <span class="hljs-string">&#x27;)&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c2 == <span class="hljs-string">&#x27;(&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((c1 == <span class="hljs-string">&#x27;*&#x27;</span> || c1 == <span class="hljs-string">&#x27;/&#x27;</span>) &amp;&amp; (c2 == <span class="hljs-string">&#x27;+&#x27;</span> || c2==<span class="hljs-string">&#x27;-&#x27;</span>) )<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><h3 id="【模板】队列"><a href="#【模板】队列" class="headerlink" title="【模板】队列"></a>【模板】队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxSize = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//构建队列</span><br>    <span class="hljs-type">int</span> data[maxSize];<br>    <span class="hljs-type">int</span> front = <span class="hljs-number">0</span>; <span class="hljs-comment">//队头</span><br>    <span class="hljs-type">int</span> rear = <span class="hljs-number">0</span>; <span class="hljs-comment">//队尾</span><br>    <br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        string c;<br>        cin&gt;&gt;c;<br>        <span class="hljs-keyword">if</span>(c ==<span class="hljs-string">&quot;push&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            data[rear] = x;<br>            rear = (rear+<span class="hljs-number">1</span>) % maxSize;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&quot;pop&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(front == rear)<br>                cout&lt;&lt;<span class="hljs-string">&quot;error&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cout&lt;&lt;data[front]&lt;&lt;endl;     <br>                front = (front+<span class="hljs-number">1</span>) % maxSize;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&quot;front&quot;</span>)<br>        &#123;<br>             <span class="hljs-keyword">if</span>(front == rear)<br>                cout&lt;&lt;<span class="hljs-string">&quot;error&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span><br>                cout&lt;&lt;data[front]&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【模板】循环队列"><a href="#【模板】循环队列" class="headerlink" title="【模板】循环队列"></a>【模板】循环队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//构建队列</span><br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    n = n+<span class="hljs-number">1</span>;<span class="hljs-comment">//多一个空间</span><br>    <span class="hljs-type">int</span> data[n];<br>    <span class="hljs-type">int</span> front = <span class="hljs-number">0</span>; <span class="hljs-comment">//队头</span><br>    <span class="hljs-type">int</span> rear = <span class="hljs-number">0</span>; <span class="hljs-comment">//队尾</span><br>    <br>    <span class="hljs-type">int</span> q;<br>    cin&gt;&gt;q;<br>    <br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        string c;<br>        cin&gt;&gt;c;<br>        <span class="hljs-keyword">if</span>(c ==<span class="hljs-string">&quot;push&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            <span class="hljs-keyword">if</span>((rear+<span class="hljs-number">1</span>)%n == front)<br>                cout&lt;&lt;<span class="hljs-string">&quot;full&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span>&#123;<br>                data[rear] = x;<br>                rear = (rear+<span class="hljs-number">1</span>) % n;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&quot;pop&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(front == rear)<br>                cout&lt;&lt;<span class="hljs-string">&quot;empty&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cout&lt;&lt;data[front]&lt;&lt;endl;     <br>                front = (front+<span class="hljs-number">1</span>) % n;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&quot;front&quot;</span>)<br>        &#123;<br>             <span class="hljs-keyword">if</span>(front == rear)<br>                cout&lt;&lt;<span class="hljs-string">&quot;empty&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span><br>                cout&lt;&lt;data[front]&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进阶-1"><a href="#进阶-1" class="headerlink" title="进阶"></a>进阶</h2><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><p><strong>描述</strong></p><pre><code class="hljs">用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">push</span>(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(stack2.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(stack1.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>)&#123;<br>                stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());<br>                stack1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        t = stack2.<span class="hljs-built_in">top</span>();<br>        stack2.<span class="hljs-built_in">pop</span>();     <br>        <br>        <span class="hljs-keyword">return</span> t; <br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack1;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack2;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序相关代码</title>
    <link href="/2022/09/06/03.%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/09/06/03.%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><img src="https://img-blog.csdnimg.cn/40b5be7ef3fc4cd39e42db86729efcf5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6JG16Iqx5bm85YS_5Zut5Zut6ZW_,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6eb1c677cdfc4120a63ff0d9a72f1e86.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6JG16Iqx5bm85YS_5Zut5Zut6ZW_,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="基础排序"><a href="#基础排序" class="headerlink" title="基础排序"></a>基础排序</h1><h2 id="插入类排序"><a href="#插入类排序" class="headerlink" title="插入类排序"></a>插入类排序</h2><blockquote><p>直接插入排序、折半插入排序、希尔排序</p></blockquote><h3 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h3><blockquote><p>基本思想：每趟将一个待排序的关键字按照大小插入到已排好的部分有序序列的适当位置中</p></blockquote><p>时间复杂度$O(n^2)$<br>空间复杂度$O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> i, j;<br>        <span class="hljs-type">int</span> t;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i&lt; arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>            t = arr[i];<br>            j = i<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; t)<br>            &#123;<br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>                j--;<br>            &#125;<br>            arr[j+<span class="hljs-number">1</span>] = t;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="折半插入"><a href="#折半插入" class="headerlink" title="折半插入"></a>折半插入</h3><blockquote><p>基本思想：采用折半查找法来查找插入位置<br>序列已经有序，查找插入位置</p></blockquote><p>时间复杂度$O(nlogn)$<br>空间复杂度$O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 折半插入</span><br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>       <span class="hljs-comment">// write code here</span><br>       <span class="hljs-type">int</span> i, j, t;<br>       <span class="hljs-type">int</span> low, mid, high;<br>       <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i&lt; arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>           t = arr[i];<br>           low = <span class="hljs-number">0</span>;<br>           high = i<span class="hljs-number">-1</span>;<br>           <span class="hljs-comment">// 折半查找</span><br>           <span class="hljs-keyword">while</span>(low &lt;= high)<br>           &#123;<br>               mid = (low+high)/<span class="hljs-number">2</span>;<br>               <span class="hljs-keyword">if</span>(arr[mid]&gt;t)<br>                   high = mid<span class="hljs-number">-1</span>;<br>               <span class="hljs-keyword">else</span><br>                   low = mid+<span class="hljs-number">1</span>;<br>           &#125;<br>           <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>; j&gt;=high+<span class="hljs-number">1</span>; j--)<br>           &#123;<br>               arr[j+<span class="hljs-number">1</span>] = arr[j];<br>           &#125;<br>           arr[high+<span class="hljs-number">1</span>] = t;<br>           <br>           <br>       &#125;<br>       <span class="hljs-keyword">return</span> arr;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>基本思想：缩小增量排序+直接插入排序</p></blockquote><p>时间复杂度$O(n^2)$<br>空间复杂度$O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-comment">// 希尔排序</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-type">int</span> gap;<span class="hljs-comment">//增量</span><br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(gap = n/<span class="hljs-number">2</span>; gap&gt;<span class="hljs-number">0</span>; gap=gap/<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;gap; i++)&#123;<br>            <span class="hljs-keyword">for</span>(j=i+gap; j &lt; n; j+=gap)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(arr[j] &lt; arr[j-gap])<br>                &#123;<br>                    <span class="hljs-type">int</span> t = arr[j];<br>                    <span class="hljs-type">int</span> k = j-gap;<br>                    <span class="hljs-keyword">while</span>(k&gt;=<span class="hljs-number">0</span> &amp;&amp; arr[k] &gt;=t)<br>                    &#123;<br>                        arr[k+gap] = arr[k];<br>                        k -= gap;<br>                    &#125;<br>                    arr[k+gap] = t;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h2><blockquote><p>冒泡排序、快速排序</p></blockquote><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><img src="https://img-blog.csdnimg.cn/12014dd1a0f0418989d74860c39fef76.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-type">int</span> i, j, t;<br>    <span class="hljs-type">int</span> flag;<span class="hljs-comment">//标记是否发生了变化</span><br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(i=n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">1</span>; --i)<br>    &#123;<br>        flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;i; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(arr[j+<span class="hljs-number">1</span>]&lt;arr[j])<br>            &#123;<br>                t = arr[j+<span class="hljs-number">1</span>];<br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>                arr[j] = t;<br>                flag = <span class="hljs-number">1</span>;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p>通过多次划分操作实现排序<br>每一趟选择当前所有子序列中的一个关键字（第一个）作为轴，将比轴小的放在前面，大的放在后面</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-comment">//快速排序</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-built_in">srand</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">QuickSort</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i = low, j = high;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-keyword">if</span>(low&lt;high)<br>    &#123;<br>        t = arr[low];<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(j&gt;i &amp;&amp; arr[j] &gt;= t)<br>                j--;<br>            <span class="hljs-keyword">if</span>(i&lt;j)<br>            &#123;<br>                arr[i] = arr[j];<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; arr[i] &lt;= t)<br>                i++;<br>            <span class="hljs-keyword">if</span>(i&lt;j)<br>            &#123;<br>                arr[j] = arr[i];<br>                j--;<br>            &#125;<br>        &#125;<br>        arr[i] = t;<br>        <span class="hljs-built_in">QuickSort</span>(arr, low, i<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">QuickSort</span>(arr, i+<span class="hljs-number">1</span>, high);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择类排序"><a href="#选择类排序" class="headerlink" title="选择类排序"></a>选择类排序</h2><blockquote><p>简单选择排序、堆排序</p></blockquote><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><blockquote><p>从头到尾顺序扫描序列，找到最小的一个关键字和第一个关键字交换</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 简单选择排序</span><br>     <span class="hljs-comment">//快速排序</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-type">int</span> i,j,k;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        k = i;<br>        <span class="hljs-keyword">for</span>(j = i+<span class="hljs-number">1</span>; j&lt;arr.<span class="hljs-built_in">size</span>(); j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(arr[j]&lt;arr[k])<br>                k = j;<br>        &#125;<br>        t = arr[i];<br>        arr[i] = arr[k];<br>        arr[k] = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>堆是一种数据结构，可以把堆看成一棵完全二叉树</li><li>完全二叉树满足:任何一个非叶结点的值都不大于（或不小于）其左右孩子结点的值。</li><li>若父亲大孩子小，则这样的堆叫作大顶堆;</li><li>若父亲小孩子大，则这样的堆叫作小顶堆。</li></ul><p><strong>将序列调整为堆</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//堆排序</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> arr;<br>    <br>    <span class="hljs-built_in">HeapSort</span>(arr, arr.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// 在数组arr[low]到arr[high]对位置low上的结点进行调整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sift</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = low, j = <span class="hljs-number">2</span>*i; <span class="hljs-comment">//arr[j]为arr[i]的左孩子结点</span><br>    <span class="hljs-type">int</span> t = arr[i];<br>    <span class="hljs-keyword">while</span>(j&lt;=high)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(j&lt;high &amp;&amp; arr[j]&lt;arr[j+<span class="hljs-number">1</span>]) <span class="hljs-comment">//右孩子大，指向右孩子</span><br>            ++j;<br>        <span class="hljs-keyword">if</span>(t &lt; arr[j])<br>        &#123;<br>            arr[i] = arr[j];<br>            i = j;<br>            j = <span class="hljs-number">2</span>*i;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    arr[i] = t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-keyword">for</span>(i = n/<span class="hljs-number">2</span>; i&gt;=<span class="hljs-number">0</span>; --i)&#123; <span class="hljs-comment">//初始堆,找到最大的节点</span><br>        <span class="hljs-built_in">Sift</span>(arr, i, n<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">1</span>; --i)<br>    &#123;<br>    <span class="hljs-comment">//将最大的节点放在最后面</span><br>        t = arr[<span class="hljs-number">0</span>];<br>        arr[<span class="hljs-number">0</span>] = arr[i];<br>        arr[i] = t;<br>        <span class="hljs-built_in">Sift</span>(arr, <span class="hljs-number">0</span>, i<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并类排序"><a href="#归并类排序" class="headerlink" title="归并类排序"></a>归并类排序</h2><blockquote><p>二路归并排序</p></blockquote><h2 id="进阶应用"><a href="#进阶应用" class="headerlink" title="进阶应用"></a>进阶应用</h2>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表相关代码</title>
    <link href="/2022/09/06/03.%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/09/06/03.%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><code> 提示：这些是自己整理 可以借鉴 也可能存在错误 欢迎指正</code></p><h1 id="数据结构介绍"><a href="#数据结构介绍" class="headerlink" title="数据结构介绍"></a>数据结构介绍</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>链表存储结构</strong> ：以<code>指针</code>指向来表示数据元素之间的逻辑关系。</p><p>（单）链表是由<code>节点</code>和<code>指针</code>构成的数据结构，每个节点存有一个值，和一个指向下一个节点的指针，因此很多链表问题可以用递归来处理。</p><p><img src="https://img-blog.csdnimg.cn/f6be0b9b583540a5838b399362c10b31.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6JG16Iqx5bm85YS_5Zut5Zut6ZW_,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/37f700b85cac4ae989c8118794ee282a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6JG16Iqx5bm85YS_5Zut5Zut6ZW_,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><h3 id="1-模板链表"><a href="#1-模板链表" class="headerlink" title="1. 模板链表"></a>1. 模板链表</h3><p>请你实现一个链表。<br><strong>操作：</strong></p><pre><code class="hljs">insert x y：将y加入链表，插入在第一个值为x的结点之前。若链表中不存在值为x的结点，则插入在链表末尾。保证x,y为int型整数。delete x：删除链表中第一个值为xx的结点。若不存在值为xx的结点，则不删除。</code></pre><p><strong>输入描述：</strong></p><pre><code class="hljs">第一行输入一个整数n ，表示操作次数。接下来的n行，每行一个字符串，表示一个操作。保证操作是题目描述中的一种。</code></pre><p><strong>输出描述：</strong></p><pre><code class="hljs">输出一行，将链表中所有结点的值按顺序输出。若链表为空，输出&quot;NULL&quot;(不含引号)。</code></pre><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<br>5<br>insert 0 1<br>insert 0 3<br>insert 1 2<br>insert 3 4<br>delete 4<br>输出：2 1 3<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span> *next;<br>&#125;List, *LinkList;<br><br><span class="hljs-function">LinkList <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, LinkList p)</span> </span>&#123;<span class="hljs-comment">// 在inv前插入x；</span><br>    LinkList Pre, t, Init;<br>    Pre = p; <br>    t = p-&gt;next;<br>    <span class="hljs-comment">//插入新结点、需要先new</span><br>    Init = <span class="hljs-keyword">new</span> List;<br>    Init-&gt;data = y;<br>    Init-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-comment">//先判断链表为不为空</span><br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        Pre-&gt;next = Init;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(t)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(t-&gt;data == x)<br>        &#123;<br>            Init-&gt;next = t;<br>            Pre-&gt;next = Init;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<span class="hljs-keyword">else</span><br>        &#123;<br>            t = t-&gt;next;<br>            Pre = Pre-&gt;next;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        Pre-&gt;next = Init;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>  <br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><br><span class="hljs-comment">//删除结点</span><br><span class="hljs-function">LinkList <span class="hljs-title">Deletenode</span><span class="hljs-params">(<span class="hljs-type">int</span> x, LinkList p)</span></span>&#123;<br>    LinkList t, q;<br>    t = p-&gt;next;<br>    q = p;<br>    <span class="hljs-keyword">while</span>(t!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(t-&gt;data != x)&#123;<br>             t = t-&gt;next;<br>             q = q-&gt;next;<br>        &#125;<span class="hljs-keyword">else</span><br>        &#123;<br>             q-&gt;next = t-&gt;next;<br>             <span class="hljs-built_in">free</span>(t);<br>             <span class="hljs-keyword">return</span> p;<br>        &#125;       <br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<span class="hljs-comment">//输入操作次数</span><br>    LinkList head = <span class="hljs-keyword">new</span> List;<span class="hljs-comment">//新建链表</span><br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        string c;<br>        cin&gt;&gt;c;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&quot;insert&quot;</span>)&#123;<br>            <span class="hljs-type">int</span> x, y;<br>            cin&gt;&gt;x&gt;&gt;y;<br>            head = <span class="hljs-built_in">Insert</span>(x, y, head);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            head = <span class="hljs-built_in">Deletenode</span>(x, head);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//输出链表</span><br>    LinkList t;<br>    t = head-&gt;next;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;NULL&quot;</span>;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(t)&#123;<br>        cout&lt;&lt;t-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        t = t-&gt;next;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Reverse-Linked-List-反转链表"><a href="#2-Reverse-Linked-List-反转链表" class="headerlink" title="2. Reverse Linked List(反转链表)"></a>2. Reverse Linked List(反转链表)</h3><blockquote><p>翻转链表</p></blockquote><pre><code class="hljs">输入输出样式：输入：一个链表输出：链表翻转后的结果例如：输入： 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出：5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * C语言声明定义全局变量请加上static，防止重复定义</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param pHead ListNode类 </span><br><span class="hljs-comment"> * @return ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* <span class="hljs-built_in">ReverseList</span>(<span class="hljs-keyword">struct</span> ListNode* pHead ) &#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> pHead;<br>    <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* A = (<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br>    A-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* t, *p;<br>    t = A;<br>    p = pHead-&gt;next;<br>    <span class="hljs-comment">//头插法建链表</span><br>    <span class="hljs-keyword">while</span>(pHead != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        pHead-&gt;next = t-&gt;next;<br>        t-&gt;next = pHead;<br>        pHead = p;<br>        p = p-&gt;next;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> A-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-合并两个排序链表"><a href="#3-合并两个排序链表" class="headerlink" title="3.合并两个排序链表"></a>3.合并两个排序链表</h3><pre><code class="hljs">输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</code></pre><p>如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param pHead1 ListNode类 </span><br><span class="hljs-comment"> * @param pHead2 ListNode类 </span><br><span class="hljs-comment"> * @return ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* <span class="hljs-built_in">Merge</span>(<span class="hljs-keyword">struct</span> ListNode* pHead1, <span class="hljs-keyword">struct</span> ListNode* pHead2)&#123;<br>    <br>    <span class="hljs-keyword">if</span>(pHead1 == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> pHead2;<br>    <span class="hljs-keyword">if</span>(pHead2 == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> pHead1;<br>    <br>    <span class="hljs-comment">//构建新结点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* C = (<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* Ct;<br>    Ct = C;<br>    <br>    <span class="hljs-comment">//头结点包含数据</span><br>    <span class="hljs-keyword">while</span>(pHead2 != <span class="hljs-literal">NULL</span> &amp;&amp; pHead1 !=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(pHead1-&gt;val &lt;= pHead2-&gt;val)&#123;<br>            Ct-&gt;next = pHead1;<br>            pHead1 = pHead1-&gt;next;<br>            Ct = Ct-&gt;next;<br>           <br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            Ct-&gt;next = pHead2;<br>            pHead2 = pHead2-&gt;next;<br>            Ct = Ct-&gt;next;<br>           <br>        &#125;<br>        <br>    &#125;<br>    Ct-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(pHead1 != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        Ct-&gt;next = pHead1;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pHead2 != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        Ct-&gt;next = pHead2;<br>    &#125;<br>    <br>     <span class="hljs-keyword">return</span> C-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-删除链表的节点"><a href="#4-删除链表的节点" class="headerlink" title="4. 删除链表的节点"></a>4. 删除链表的节点</h3><pre><code class="hljs">输入：&#123;2,5,1,9&#125;,5返回值：&#123;2,1,9&#125;说明：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 2 -&gt; 1 -&gt; 9 </code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * C语言声明定义全局变量请加上static，防止重复定义</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param head ListNode类 </span><br><span class="hljs-comment"> * @param val int整型 </span><br><span class="hljs-comment"> * @return ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* <span class="hljs-built_in">deleteNode</span>(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span> val ) &#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* t, *pre;<br>    pre = head;<br>    t = head;<br>    <br>    <span class="hljs-keyword">if</span>(head-&gt;val == val)<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    <br>    t = t-&gt;next;<br>    <span class="hljs-keyword">while</span>(t != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(t-&gt;val == val)<br>        &#123;<br>            pre-&gt;next = t-&gt;next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        t = t-&gt;next;<br>        pre = pre-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-环形链表的约瑟夫问题"><a href="#5-环形链表的约瑟夫问题" class="headerlink" title="5. 环形链表的约瑟夫问题"></a>5. 环形链表的约瑟夫问题</h3><p><strong>描述</strong></p><pre><code class="hljs">编号为 1 到 n 的 n 个人围成一圈。从编号为 1 的人开始报数，报到 m 的人离开。下一个人继续从 1 开始报数。n-1 轮结束以后，只剩下一个人，问最后留下的这个人编号是多少？</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @param m int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ysf</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-comment">//初始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            nums[i] = i;<br>        <br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(nums.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> id_away = (s+m<span class="hljs-number">-1</span>)%nums.<span class="hljs-built_in">size</span>();<br>            <br>            nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>() + id_away);<span class="hljs-comment">//移除下标为id_away</span><br>            <span class="hljs-comment">//erase(position)函数---移除position处的一个字符</span><br>            <br>            s = id_away;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-判断链表中是否有环"><a href="#6-判断链表中是否有环" class="headerlink" title="6.判断链表中是否有环"></a>6.判断链表中是否有环</h3><p><strong>描述</strong></p><pre><code class="hljs">判断给定的链表中是否有环。如果有环则返回true，否则返回false。</code></pre><p><strong>解题思路</strong></p><ul><li>哈希</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        unordered_map&lt;ListNode*, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-comment">//哈希记录结点出现的次数</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        ListNode* p = head;<br>        <span class="hljs-keyword">while</span>(p !=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(p))&#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                mp[p]++;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-两个链表的第一个公共结点"><a href="#7-两个链表的第一个公共结点" class="headerlink" title="7.  两个链表的第一个公共结点"></a>7.  两个链表的第一个公共结点</h3><p><strong>描述</strong></p><pre><code class="hljs">输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</code></pre><p><strong>具体做法：</strong></p><ul><li>step 1：单独的遍历两个链表，得到各自的长度。</li><li>step 2：求得两链表的长度差nnn，其中较长的链表的指针从头先走nnn步。</li><li>step 3：两链表指针同步向后遍历，遇到第一个相同的节点就是第一个公共节点。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//计算链表长度</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Listlenth</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        ListNode* p = head;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)&#123;<br>            res++;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n1 = <span class="hljs-built_in">Listlenth</span>(pHead1);<br>        <span class="hljs-type">int</span> n2 = <span class="hljs-built_in">Listlenth</span>(pHead2);<br>        <span class="hljs-comment">//链表1长于链表2</span><br>        <span class="hljs-keyword">if</span>(n1 &gt;= n2)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;(n1-n2); i++)&#123;<br>                pHead1 = pHead1-&gt;next;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;(n2-n1); i++)<br>                pHead2 = pHead2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>((pHead1!=<span class="hljs-literal">NULL</span>) &amp;&amp; (pHead2!=<span class="hljs-literal">NULL</span>) &amp;&amp; (pHead1 != pHead2))&#123;<br>            pHead1 = pHead1-&gt;next;<br>            pHead2 = pHead2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pHead1;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h3 id="1-链表内指定区间反转"><a href="#1-链表内指定区间反转" class="headerlink" title="1. 链表内指定区间反转"></a>1. 链表内指定区间反转</h3><pre><code class="hljs">   将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)O(n)，空间复杂度 O(1)O(1)。例如：给出的链表为 1→2→3→4→5→NULL, m=2,n=4返回 1→4→3→2→5→NULL.     </code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @param m int整型 </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* rehead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        rehead-&gt;next = head;<br>        ListNode *p = rehead, *q = rehead;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;m; i++)<br>            p = p-&gt;next;<br>        <br>        ListNode *s = p-&gt;next;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n-m; i++)&#123;<br>            ListNode *t = s-&gt;next;<br>            s-&gt;next = t-&gt;next;<br>            t-&gt;next = p-&gt;next;<br>            <span class="hljs-comment">//t-&gt;next = s; 不能为s s一直在变换</span><br>            p-&gt;next = t;  <br>        &#125;<br>        <span class="hljs-keyword">return</span> rehead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-链表中的节点每k个一组翻转"><a href="#2-链表中的节点每k个一组翻转" class="headerlink" title="2.链表中的节点每k个一组翻转"></a>2.链表中的节点每k个一组翻转</h3><pre><code class="hljs">将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样你不能更改节点中的值，只能更改节点本身。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @param k int整型 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* rehead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        rehead-&gt;next = head;<br>        ListNode *p = rehead, *q = rehead;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;m; i++)<br>            p = p-&gt;next;<br>        <br>        ListNode *s = p-&gt;next;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n-m; i++)&#123;<br>            ListNode *t = s-&gt;next;<br>            s-&gt;next = t-&gt;next;<br>            t-&gt;next = p-&gt;next;<br>            <span class="hljs-comment">//t-&gt;next = s; 不能为s s一直在变换</span><br>            p-&gt;next = t;  <br>        &#125;<br>        <span class="hljs-keyword">return</span> rehead-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span> ||head-&gt;next==<span class="hljs-literal">NULL</span> || k==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br>        ListNode *t = head;<br>        <span class="hljs-keyword">while</span>(t)&#123;<br>            length++;<br>            t = t-&gt;next;<br>        &#125;<br>        t = head;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=length; i+=k)&#123;<br>            <span class="hljs-keyword">if</span>(i+k<span class="hljs-number">-1</span> &gt; length)<br>                <span class="hljs-keyword">break</span>;<span class="hljs-comment">//请注意！！！</span><br>            ListNode* p = <span class="hljs-built_in">reverseBetween</span>(t, i, k+i<span class="hljs-number">-1</span>);<span class="hljs-comment">//请注意！！！ 直接t = reverseBetween(); 会发生数组越界</span><br>            t = p;<br>        &#125;<br> <br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-链表中环的入口结点"><a href="#3-链表中环的入口结点" class="headerlink" title="3.链表中环的入口结点"></a>3.链表中环的入口结点</h3><p><strong>描述</strong></p><pre><code class="hljs">给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</code></pre><p><strong>解题思路</strong></p><ul><li>哈希，记录结点出现次数</li><li>超过1 ，表示环的入口出现</li><li>同“判断链表中是否有环”</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        unordered_map&lt;ListNode*, <span class="hljs-type">int</span>&gt; mp;<br>        ListNode* p = pHead;<br>        ListNode* res;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(mp[p] &gt; <span class="hljs-number">1</span>)&#123;<br>                res = p;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span><br>                mp[p]++;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-删除链表的倒数第n个节点"><a href="#4-删除链表的倒数第n个节点" class="headerlink" title="4.删除链表的倒数第n个节点"></a>4.删除链表的倒数第n个节点</h3><p><strong>描述</strong></p><pre><code class="hljs">给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针例如，给出的链表为: 1→2→3→4→5, n=2.删除了链表的倒数第 n 个节点之后,链表变为1→2→3→5.</code></pre><p><strong>解题思路</strong></p><ul><li>三个指针</li><li>指向当前结点now、指向当前结点的前一个结点pre、指向想隔n的结点p</li><li>直到p为空，删除now结点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        res-&gt;next = head;<br>        ListNode* now = head;<span class="hljs-comment">//当前结点</span><br>        ListNode* pre = res;<span class="hljs-comment">//当前结点的前一个结点</span><br>        ListNode* p = head;<span class="hljs-comment">//相隔n结点</span><br>        <span class="hljs-keyword">while</span>(n--)&#123;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>            p = p-&gt;next;<br>            now = now-&gt;next;<br>            pre = pre-&gt;next;<br>        &#125;<br>        pre-&gt;next = now-&gt;next;<span class="hljs-comment">//删除结点</span><br>        <span class="hljs-keyword">return</span> res-&gt;next;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-链表相加"><a href="#5-链表相加" class="headerlink" title="5.链表相加"></a>5.链表相加</h3><p><strong>描述</strong></p><pre><code class="hljs">假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。给定两个这种链表，请生成代表两个整数相加值的结果链表。数据范围：0≤n,m≤1000000，链表任意值 0≤val≤9要求：空间复杂度 O(n)，时间复杂度 O(n)</code></pre><p><strong>解题思路：</strong></p><ul><li>先反转</li><li>应用大数加法的逻辑</li><li>注意：建立新的链表更适合</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head1 ListNode类 </span><br><span class="hljs-comment">     * @param head2 ListNode类 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-comment">//将链表先反转 然后再从头开始相加</span><br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">if</span>(head-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>            <br>        ListNode* pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        pre-&gt;next = head;<br>        ListNode* p = head-&gt;next;<span class="hljs-comment">//从头结点的下一个结点开始一个一个头插法</span><br><br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)&#123;<br>            head-&gt;next = p-&gt;next;<br>            p-&gt;next = pre-&gt;next;<br>            pre-&gt;next = p;<br>            p = head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">addInList</span><span class="hljs-params">(ListNode* head1, ListNode* head2)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(head1 == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> head2;<br>        <span class="hljs-keyword">if</span>(head2 == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> head1;<br>        <span class="hljs-comment">//反转链表</span><br>        ListNode* p1 = <span class="hljs-built_in">reverseList</span>(head1);<br>        ListNode* p2 = <span class="hljs-built_in">reverseList</span>(head2);<br>        ListNode* res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>), *cur = res;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p1 || p2 || flag)&#123;<br>            <span class="hljs-type">int</span> x,y;<br>            <span class="hljs-keyword">if</span>(p1)<br>                x = p1-&gt;val;<br>            <span class="hljs-keyword">else</span><br>                x = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(p2)<br>                y = p2-&gt;val;<br>            <span class="hljs-keyword">else</span><br>                y = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> sum = x+y+flag;<br>            flag = sum/<span class="hljs-number">10</span>;<br>            sum = sum%<span class="hljs-number">10</span>;<br>            cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum);<br>            cur = cur-&gt;next;<br>            <span class="hljs-keyword">if</span>(p1) p1=p1-&gt;next;<br>            <span class="hljs-keyword">if</span>(p2) p2=p2-&gt;next;<br>        &#125;<br>        res = res-&gt;next;<br>        res = <span class="hljs-built_in">reverseList</span>(res);<br>        <span class="hljs-keyword">return</span> res;   <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="较难"><a href="#较难" class="headerlink" title="较难"></a>较难</h2><h3 id="合并k个已排序的链表"><a href="#合并k个已排序的链表" class="headerlink" title="合并k个已排序的链表"></a>合并k个已排序的链表</h3><p><strong>解题思路：</strong>      </p><pre><code class="hljs">在两个有序链表合并的基础上，依次合并----时间复杂度高解决办法：折半法</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//合并两个链表</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* <span class="hljs-built_in">Merge</span>(<span class="hljs-keyword">struct</span> ListNode* pHead1, <span class="hljs-keyword">struct</span> ListNode* pHead2)&#123;<br>    <br>    <span class="hljs-keyword">if</span>(pHead1 == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> pHead2;<br>    <span class="hljs-keyword">if</span>(pHead2 == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> pHead1;<br>    <br>    <span class="hljs-comment">//构建新结点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* C = (<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* Ct;<br>    Ct = C;<br>    <br>    <span class="hljs-comment">//头结点包含数据</span><br>    <span class="hljs-keyword">while</span>(pHead2 != <span class="hljs-literal">NULL</span> &amp;&amp; pHead1 !=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(pHead1-&gt;val &lt;= pHead2-&gt;val)&#123;<br>            Ct-&gt;next = pHead1;<br>            pHead1 = pHead1-&gt;next;<br>            Ct = Ct-&gt;next;&#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            Ct-&gt;next = pHead2;<br>            pHead2 = pHead2-&gt;next;<br>            Ct = Ct-&gt;next;<br>        &#125; <br>    &#125;<br>    Ct-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(pHead1 != <span class="hljs-literal">NULL</span>)&#123;<br>        Ct-&gt;next = pHead1;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pHead2 != <span class="hljs-literal">NULL</span>)&#123;<br>        Ct-&gt;next = pHead2;<br>    &#125;    <br>     <span class="hljs-keyword">return</span> C-&gt;next;<br>&#125;<br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;<br>      <span class="hljs-comment">//  ListNode *res = nullptr;</span><br>      <span class="hljs-comment">//  for(int i=0; i&lt;lists.size(); i++)&#123;</span><br>      <span class="hljs-comment">//      res = Merge(res, lists[i]);</span><br>      <span class="hljs-comment">//  &#125;</span><br>      <span class="hljs-comment">//  return res;</span><br>        <span class="hljs-comment">//超出时间</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">divideMerge</span>(lists, <span class="hljs-number">0</span>, lists.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">//划分合并区间函数</span><br>    <span class="hljs-function">ListNode *<span class="hljs-title">divideMerge</span><span class="hljs-params">(vector&lt;ListNode *&gt; &amp;lists, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left &gt; right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == right)<br>            <span class="hljs-keyword">return</span> lists[left];<br>        <br>        <span class="hljs-comment">//从中间分成两段，再讲合并好的两端合并</span><br>        <span class="hljs-type">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Merge</span>(<span class="hljs-built_in">divideMerge</span>(lists, left, mid), <span class="hljs-built_in">divideMerge</span>(lists, mid+<span class="hljs-number">1</span>, right));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="设计LRU缓存结构描述"><a href="#设计LRU缓存结构描述" class="headerlink" title="设计LRU缓存结构描述"></a>设计LRU缓存结构描述</h3><p><strong>描述</strong></p><pre><code class="hljs">设计LRU(最近最少使用)缓存结构，该结构在构造时确定大小，假设大小为 capacity ，操作次数是 n ，并有如下功能:1. Solution(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存2. get(key)：如果关键字 key 存在于缓存中，则返回key对应的value值，否则返回 -1 。3. set(key, value)：将记录(key, value)插入该结构，如果关键字 key 已经存在，则变更其数据值 value，如果不存在，则向缓存中插入该组 key-value ，如果key-value的数量超过capacity，弹出最久未使用的key-value</code></pre><p><strong>提示</strong></p><p>提示:</p><pre><code class="hljs">1.某个key的set或get操作一旦发生，则认为这个key的记录成了最常使用的，然后都会刷新缓存。2.当缓存的大小超过capacity时，移除最不经常使用的记录。3.返回的value都以字符串形式表达，如果是set，则会输出&quot;null&quot;来表示(不需要用户返回，系统会自动输出)，方便观察4.函数set和get必须以O(1)的方式运行5.为了方便区分缓存里key与value，下面说明的缓存里key用&quot;&quot;号包裹</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-comment">//构造结点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        Node* pre;<br>        Node* next;<br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v): <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">pre</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;;<br>    &#125;;<br>    <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//全局变量，记录双向链表的头和尾、LRU剩余的大小</span><br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> cap;<br>    Node* head = <span class="hljs-literal">NULL</span>;<br>    Node* tail = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//双向链表</span><br>    <span class="hljs-comment">//哈希表</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; mp;<br>    <br>    <span class="hljs-built_in">Solution</span>(<span class="hljs-type">int</span> capacity)&#123;<br>         <span class="hljs-comment">// write code here</span><br>        <span class="hljs-comment">//初始化</span><br>        size = <span class="hljs-number">0</span>;<br>        cap = capacity; <br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        head-&gt;next = tail;<br>        tail-&gt;pre = head;<br>        mp.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>         <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(key))&#123;<br>            <span class="hljs-built_in">movehead</span>(mp[key]);<br>            <span class="hljs-keyword">return</span> mp[key]-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span></span>&#123;<br>         <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(key))&#123;<br>            <span class="hljs-built_in">movehead</span>(mp[key]);<br>            mp[key]-&gt;val = value;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            size++;<br>            <span class="hljs-keyword">if</span>(size &gt; cap)&#123;<br>                <span class="hljs-comment">//缓存已满，更新尾，将尾删除</span><br>                Node* ans = <span class="hljs-built_in">deletenode</span>();<br>                <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(ans-&gt;key))&#123;<br>                    mp.<span class="hljs-built_in">erase</span>(ans-&gt;key);<br>                    <span class="hljs-keyword">delete</span> ans;<br>                    size--;<br>                &#125;<br>                Node* t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>                mp[key] = t;<br>                <span class="hljs-built_in">addhead</span>(t);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//内存未满，直接在头部插入</span><br>                Node* t  = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>                mp[key] = t;<br>                <span class="hljs-built_in">addhead</span>(t);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//移到头结点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">movehead</span><span class="hljs-params">(Node* p)</span></span>&#123;<br>        <span class="hljs-built_in">removenode</span>(p);<br>        <span class="hljs-built_in">addhead</span>(p);<br>    &#125;<br><br>    <span class="hljs-comment">//移除结点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removenode</span><span class="hljs-params">(Node* p)</span></span>&#123;<br>        p-&gt;next-&gt;pre = p-&gt;pre;<br>        p-&gt;pre-&gt;next = p-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">//添加头结点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addhead</span><span class="hljs-params">(Node* p)</span></span>&#123;<br>        p-&gt;pre = head;<br>        p-&gt;next = head-&gt;next;<br>        head-&gt;next-&gt;pre = p;<br>        head-&gt;next = p;<br>    &#125;<br>    <br>    <span class="hljs-function">Node* <span class="hljs-title">deletenode</span><span class="hljs-params">()</span></span>&#123;<br>        Node* t = tail-&gt;pre;<br>        <span class="hljs-built_in">removenode</span>(t);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>关于哈希表的用法</strong></p><pre><code class="hljs">unordered_map是一个将key和value关联起来的容器，它可以高效的根据单个key值查找对应的value。key值应该是唯一的，key和value的数据类型可以不相同。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">定义：<br>unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; haxi;<br>增加：<br>haxi.<span class="hljs-built_in">insert</span>(p);<br>删除<br>haxi.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//根据key删除</span><br>查找<br><span class="hljs-built_in">haxi</span>(<span class="hljs-built_in">count</span>(key))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vs基础模板、c++模板</title>
    <link href="/2022/09/06/03.vs%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BFc++/"/>
    <url>/2022/09/06/03.vs%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BFc++/</url>
    
    <content type="html"><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p><strong>初始化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(<span class="hljs-number">1</span>)  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <br><span class="hljs-comment">//定义了10个整型元素的向量（尖括号中为元素类型名，它可以是任何合法的数据类型），但没有给出初值，其值是不确定的。</span><br>（<span class="hljs-number">2</span> )  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>)</span></span>; <br><span class="hljs-comment">//定义了10个整型元素的向量,且给出每个元素的初值为1</span><br>（<span class="hljs-number">3</span>）<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(b)</span></span>; <span class="hljs-comment">//用b向量来创建a向量，整体复制性赋值</span><br>（<span class="hljs-number">4</span>）<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(b.begin(),b.begin+<span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-comment">//定义了a值为b中第0个到第2个（共3个）元素</span><br>（<span class="hljs-number">5</span>）<span class="hljs-type">int</span> b[<span class="hljs-number">7</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>&#125;; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(b,b+<span class="hljs-number">7</span>)</span></span>; <span class="hljs-comment">//从数组中获得初值</span><br><br></code></pre></td></tr></table></figure><p><strong>重要操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; a;<br>a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">//在a的最后一个向量后插入一个元素，其值为5</span><br>a.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//删除a向量的最后一个元素</span><br>a.<span class="hljs-built_in">erase</span>(a.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,a.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">3</span>); <span class="hljs-comment">//删除a中第1个（从第0个算起）到第2个元素</span><br>a.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">//返回a的最后一个元素</span><br>a.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//返回a的第一个元素</span><br>a.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//清空a中的元素</span><br>a.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//判断a是否为空，空则返回ture,不空则返回false</span><br><br>a.<span class="hljs-built_in">insert</span>(a.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4</span><br>a.<span class="hljs-built_in">insert</span>(a.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</span><br>a.<span class="hljs-built_in">insert</span>(a.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,b+<span class="hljs-number">3</span>,b+<span class="hljs-number">6</span>); <span class="hljs-comment">//b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8         ，插入元素后为1,4,5,9,2,3,4,5,9,8</span><br><br>a.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//将a的现有元素个数调至10个，多则删，少则补，其值随机</span><br>a.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//将a的现有元素个数调至10个，多则删，少则补，其值为2</span><br><br>a.<span class="hljs-built_in">swap</span>(b); <span class="hljs-comment">//b为向量，将a中的元素和b中的元素进行整体性交换</span><br><br></code></pre></td></tr></table></figure><p><strong>重要算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br>（<span class="hljs-number">1</span>）<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span><br>（<span class="hljs-number">2</span>）<span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span><br>（<span class="hljs-number">3</span>）<span class="hljs-built_in">copy</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),b.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>); <span class="hljs-comment">//把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开        始复制，覆盖掉原有元素</span><br>（<span class="hljs-number">4</span>）<span class="hljs-built_in">find</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),<span class="hljs-number">10</span>); <span class="hljs-comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span><br><br></code></pre></td></tr></table></figure><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">push</span>(elem);<span class="hljs-comment">//入栈</span><br><span class="hljs-built_in">pop</span>();<span class="hljs-comment">//弹出栈顶元素</span><br><span class="hljs-built_in">top</span>();<span class="hljs-comment">//返回栈顶元素</span><br><br><span class="hljs-built_in">empty</span>();<span class="hljs-comment">//判断是否为空</span><br><span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回栈的大小</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学知识梳理</title>
    <link href="/2022/08/26/04.%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <url>/2022/08/26/04.%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="数学知识复习"><a href="#数学知识复习" class="headerlink" title="数学知识复习"></a>数学知识复习</h2><h3 id="1-指数运算"><a href="#1-指数运算" class="headerlink" title="1.指数运算"></a>1.指数运算</h3><p>$$X^AX^B&#x3D;X^{A+B}$$<br>$$\frac{X^A}{X^B}&#x3D;X^{A-B}$$<br>$$(X^A)^B&#x3D;X^{AB}$$<br>$$2^N+2^N&#x3D;2^{N+1}$$<br>$$X^N+X^N&#x3D;2X^N\neq{X^{2N}}$$</p><h3 id="2-对数运算"><a href="#2-对数运算" class="headerlink" title="2.对数运算"></a>2.对数运算</h3><blockquote><p>在计算机科学中，除非有特殊的声明，所有的对数都是以2为底的</p></blockquote><p>定义:$X^A&#x3D;B$,当且仅当$log_xB&#x3D;A$</p><p><strong>换底公式</strong><br>$$log_AB &#x3D; \frac{log_cB}{log_cA};C&gt;0$$<br><strong>四则运算</strong><br>$$logAB&#x3D;logAlogB$$<br>$$log\frac{A}{B} &#x3D; logA -logB$$<br>$$log(A^B)&#x3D; BlogA$$<br>$$logX &lt; X ;(X&gt;0)$$<br>$$log1&#x3D;0; log2&#x3D;1 ; log1024 &#x3D;10; log1048576 &#x3D;20$$</p><h3 id="3-级数"><a href="#3-级数" class="headerlink" title="3. 级数"></a>3. 级数</h3><p><img src="https://img-blog.csdnimg.cn/72a11f4b010641e5822bbe0f864dbf60.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6JG16Iqx5bm85YS_5Zut5Zut6ZW_,size_20,color_FFFFFF,t_70,g_se,x_16" alt="**常见公式**$$\sum_{i=0}^N2^i=2^{N+1}-1$$"></p><p><img src="https://img-blog.csdnimg.cn/bc9d1db1d397437ea27d08648ba9fa21.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构知识系统梳理</title>
    <link href="/2022/08/26/04.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <url>/2022/08/26/04.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构面试、数据结构考研复试——常见问题以及回答</p></blockquote><p>说明：这些是自己整理回答的答案 可以借鉴 也可能存在错误 欢迎指正</p><h1 id="逻辑结构与物理结构的区别"><a href="#逻辑结构与物理结构的区别" class="headerlink" title="逻辑结构与物理结构的区别"></a>逻辑结构与物理结构的区别</h1><p><strong>逻辑结构</strong> ：是指数据对象中数据元素之间的相互关系</p><p><strong>逻辑结构分类：</strong></p><pre><code class="hljs">集合——各个元素之间是“平等”的，类似于数学里面的集合线性结构——数据结构中的数据元素是一对一关系的树性结构——数据结构中的数据元素之间存在一对多的层次关系 图形结构——数据结构中的数据元素之间存在多对多的关系</code></pre><hr><p><strong>物理结构</strong> ：是指数据的逻辑结构在计算机中的存储形式</p><p><strong>物理结构的分类：</strong></p><p> <strong>1. 顺序存储结构</strong><br>     ——把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系是一致的。</p><p> <strong>2. 链式存储结构</strong><br>    ——把数据元素存放在任意的存储单元中，这组存储单元可以是连续的，也可以是不连续的。通过指针来找到下一个数据元素的地址。</p><p><strong>3.索引存储结构</strong><br>    ——B+ 树</p><p><strong>4.散列存储结构</strong></p><hr><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><strong>算法的五大特征</strong> </p><pre><code class="hljs">  - 有穷性——有限的步骤 - 确定性——不可二义性 - 可行性——每一步都是通过执行有限次数完成的 - 输入——零个或多个输入 - 输出——至少有一个或多个输出</code></pre><p><strong>好的算法</strong></p><pre><code class="hljs"> - 正确性 - 可读性 - 健壮性 ——当输入数据不合法时，算法也能做出相应的反应 - 效率与低存储需求</code></pre><p><strong>时间复杂度</strong>： 算法的执行时间与原操的执行次数之和成正比</p><p><strong>空间复杂度</strong> ： 如果输入数据所占空间只取决于问题本身，而与算法无关，只需要分析除了输入和程序之外的辅助变量所占用的空间即可。</p><h1 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h1><p><strong>数据结构</strong> ：是指相互之间存在一种或者多种特定关系的数据元素的集合</p><p><strong>常见数据结构</strong></p><pre><code class="hljs">数组——————一维数组、二维数组链表——————单链表、循环链表栈——————先进后出、递归、后缀表达式、函数调用队列——————先进先出、树的层次遍历、图的广度遍历树——————二叉树、森林、平衡二叉树、线索二叉树、遍历图——————有向图、无向图、最小二叉树、遍历、最短路径</code></pre><h1 id="链表存储结构和顺序存储结构的区别"><a href="#链表存储结构和顺序存储结构的区别" class="headerlink" title="链表存储结构和顺序存储结构的区别"></a>链表存储结构和顺序存储结构的区别</h1><p><strong>顺序存储结构</strong>：是以数据元素的<strong>相对物理位置</strong>来表示数据元素之间的逻辑关系的</p><p><strong>链表存储结构</strong> ：以<strong>指针</strong>指向来表示数据元素之间的逻辑关系。</p><table><thead><tr><th>顺序存储结构</th><th>链表存储结构</th></tr></thead><tbody><tr><td>读取方便 O(1）</td><td>读取不方便 需要遍历  O(n)</td></tr><tr><td>插入删除 需要移动大量元素</td><td>插入删除方便 只需要改变指针</td></tr><tr><td>空间分配 ：一次性</td><td>在需要时分配</td></tr><tr><td>存储密度 &#x3D; 1</td><td>存储密度 &lt; 1</td></tr></tbody></table><h1 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h1><table><thead><tr><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>事先定义长度，不能适应数据动态地增减</td><td>动态地进行存储分配，可以适应数据动态地增减</td></tr><tr><td>从栈中分配空间</td><td>从堆中分配空间</td></tr><tr><td>快速访问数据元素，插入删除不方便</td><td>查找访问数据不方便，插入删除数据发布</td></tr></tbody></table><h1 id="头指针和头结点的区别"><a href="#头指针和头结点的区别" class="headerlink" title="头指针和头结点的区别"></a>头指针和头结点的区别</h1><table><thead><tr><th>头指针</th><th>头结点</th></tr></thead><tbody><tr><td>是链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</td><td>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前。</td></tr><tr><td>是必需的</td><td>不是必需的 为了方便操作</td></tr><tr><td>具有标识作用</td><td>对于插入和删除第一结点，和其他结点操作统一</td></tr></tbody></table><h1 id="线性链表"><a href="#线性链表" class="headerlink" title="线性链表"></a>线性链表</h1><p>线性链表中一个节点代表一个存储空间，即节点。每一个节点包括两个部分，一个用来存储数据，一个存储下一个元素的地址。</p><h1 id="判断整个链表是否有环，如何找到这个环"><a href="#判断整个链表是否有环，如何找到这个环" class="headerlink" title="判断整个链表是否有环，如何找到这个环"></a>判断整个链表是否有环，如何找到这个环</h1><p>提问：给定一个单链表，只给出头指针h：<br>1.如果判断是否存在环？</p><p>2.如何知道环的长度？</p><p>3.如何找出环的连接点在哪里？</p><p>4.带环链表的长度是多少</p><p>解法：<br>1.对于判断一个单链表是否存在环，<strong>可以利用追赶的方式，设立两个指针slow、fast</strong>，从头指针开始，每次分别前进一步和两步。如果存在环，则两者相遇；如果没有环，fast遇到NULL退出。</p><p>2.在slow和fast相遇的地方标记，再次相遇所走过的操作数就是环的长度</p><p>3.分别从相遇点和头指针开始走，相遇的那个点就是连接点</p><p>4.问题3中连接点距离头指针的长度，加上问题2中求出的环的长度，即为链表的长度。</p><p> <a href="http://blog.sina.com.cn/s/blog_725dd1010100tqwp.html">http://blog.sina.com.cn/s/blog_725dd1010100tqwp.html</a>.</p><h1 id="单链表和双链表的区别"><a href="#单链表和双链表的区别" class="headerlink" title="单链表和双链表的区别"></a>单链表和双链表的区别</h1><p><strong>单链表</strong> ：只能向后访问，不能逆向访问</p><p><strong>双链表</strong> ：在单链表的基础上添加一个指向前驱结点的指针域，实现双向遍历</p><h1 id="简述KMP算法"><a href="#简述KMP算法" class="headerlink" title="简述KMP算法"></a>简述KMP算法</h1><p>KMP算法是在简单模式匹配的基础上对串的模式匹配进行优化。</p><p>主要的思路是每趟比较过程中让子串先滑动到一个合适的位置。</p><p>当发生不匹配时，不同于简单模式匹配的右移一位，而是<strong>移动到适合的位置</strong>。</p><p>这里所移动的位置依靠与NEXT[]数组，求next[]数组的方法是比较前后缀相同元素。</p><h1 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别"></a>栈和队列的区别</h1><table><thead><tr><th>栈</th><th>队列</th></tr></thead><tbody><tr><td>先进后出</td><td>先进先出</td></tr><tr><td>允许在表尾进行插入和删除</td><td>允许在一段进行插入一段进行删除</td></tr><tr><td>插入和删除都在表尾进行</td><td>在队尾插入在队头删除</td></tr><tr><td>top &#x3D;&#x3D; -1 为空</td><td>front &#x3D;&#x3D; rear 为空</td></tr><tr><td>top++ 进栈</td><td>rear &#x3D; （rear+1）%maxsize进队</td></tr><tr><td>top– 出栈</td><td>front &#x3D; （front+1）%maxsize出队</td></tr></tbody></table><p><strong>相同点</strong> ：</p><pre><code class="hljs">栈和队列都是线性结构栈和队列在插入时都是在表尾进行栈和队列都可以用顺序存储结构和链表存储结构栈和队列插入和删除操作的时间复杂度和空间复杂度是一样的</code></pre><p><strong>不同点</strong> ：</p><pre><code class="hljs">删除元素位置不同，栈在表尾，队在表头用链表存储时可以实现多栈空间共享，队列不行</code></pre><h1 id="两个栈实现队列，两个队列实现栈"><a href="#两个栈实现队列，两个队列实现栈" class="headerlink" title="两个栈实现队列，两个队列实现栈"></a>两个栈实现队列，两个队列实现栈</h1><h2 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h2><p>栈1 - - - - - - -栈2<br>    <img src="https://img-blog.csdnimg.cn/20200506150235591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE3NzU5NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>入队：把全部元素入栈1，出栈1压入栈2，实现与队列相同的顺序。</p><p>出队：在栈2 中以此出队即可。</p><p>插入新的元素：不应该在栈2内还有元素时，将栈1中插入的元素入栈，而是等栈2所有元素都出队后，再将栈1 中的元素压入栈2。</p><h1 id="树和二叉树的相关概念"><a href="#树和二叉树的相关概念" class="headerlink" title="树和二叉树的相关概念"></a>树和二叉树的相关概念</h1><h2 id="提问：二叉树和度为2的树的区别"><a href="#提问：二叉树和度为2的树的区别" class="headerlink" title="提问：二叉树和度为2的树的区别"></a>提问：二叉树和度为2的树的区别</h2><p>回答：</p><p>二叉树的特点：<br>1、每个结点最多有两颗子树，结点的度最大为2。<br>2、左子树和右子树是有顺序的，次序不能颠倒。<br>3、即使某结点只有一个子树，也要区分左右子树。<br>4、二叉树可以是空树、只有一个根结点、根结点只有左子树、根结点只有右子树、根结点左右子树都有。</p><p>度为2 的树：树的结点的最大的度为2.</p><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>先序：</p><pre><code class="hljs">先访问根结点再先序遍历左子树最后先序遍历右子树</code></pre><p>中序：</p><pre><code class="hljs">从根结点开始，中序遍历左子树访问根结点最后中序遍历右子树</code></pre><p>后序遍历</p><pre><code class="hljs">从左到右先叶子结点的方式遍历访问左右子树最后访问根结点</code></pre><p>层次遍历</p><pre><code class="hljs">从根结点的第一层开始访问从上到下进行遍历，从左到右访问结点（利用队列来实现）</code></pre><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>先跟遍历：</p><pre><code class="hljs">先访问根结点从左到右先跟遍历树的每个子树</code></pre><p>后跟遍历：</p><pre><code class="hljs">先依次后跟遍历每根子树，然后再访问根结点</code></pre><h1 id="二叉平衡树、二叉排序树"><a href="#二叉平衡树、二叉排序树" class="headerlink" title="二叉平衡树、二叉排序树"></a>二叉平衡树、二叉排序树</h1><p>二叉排序树：<br>    是比根结点大的放在右子树，比根结点小的放在左子树</p><p>二叉平衡树：<br>    在二叉排序树的基础上，只要保证每个节点左子树和右子树的高度差小于等于1就可以了。<br>    适用于插入删除比较少，但是查找比较多的情况</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><img src="https://img-blog.csdnimg.cn/2020050616004737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE3NzU5NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>主要性质：</p><pre><code class="hljs">节点是红色或者黑色，没有其他的颜色根结点是黑色，不能为红。每个叶节点是黑色，这里的叶子结 节点是指空的叶子结点不存在两个连续的红色节点，即父节点和子节点不能是连续的红色从任一节点到其每个叶节点的所有路径都包含相同数目的黑色节点。</code></pre><p>优点：平均查找，添加输出效果都还不错</p><p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。Linux内核在管理vm_area_struct（虚拟内存）时就是采用了红黑树来维护内存块的。</p><h1 id="图的相关概念"><a href="#图的相关概念" class="headerlink" title="图的相关概念"></a>图的相关概念</h1><p>图结构中结点之间的关系是任意的，图中的任意两个结点都可能有关系。</p><p>图分为有向图和无向图</p><p>有向图的基本算法：拓扑排序、最短路径（Dijkstra算法和Floyd算法）。</p><p>无向图的基本算法：最小生成树（prime算法，Kruska算法）、DFS、BFS。</p><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>邻接表：（链式存储结构）由单链表的表头形成的<strong>顶点表</strong>，和单链表其余结点形成的<strong>边表</strong>两部分组成；一般顶点表存放顶点信息和指向第一个边结点的指针</p><p>邻接矩阵：（顺序存储结构）</p><p>有向图的十字链表法</p><p>无向图的多重链表法</p><h1 id="深度优先遍历与广度优先遍历"><a href="#深度优先遍历与广度优先遍历" class="headerlink" title="深度优先遍历与广度优先遍历"></a>深度优先遍历与广度优先遍历</h1><p>深度优先遍历 类似于二叉树的先序遍历</p><p>步骤：</p><pre><code class="hljs">（1）访问起始点v（2）若v的第一个邻接点没有被访问过，则深度遍历该邻接点；（3）若v的第一个邻接点已经被访问，则访问其第二个邻接点，进行深度遍历；重复以上步骤直到所有节点都被访问过为止</code></pre><p>广度优先算法 类似于层次遍历</p><p>步骤：</p><pre><code class="hljs">（1）访问起始点v（2）依次遍历v的所有未访问过得邻接点（3）再依次访问下一层中未被访问过得邻接点；重复以上步骤，直到所有的顶点都被访问过为止</code></pre><h1 id="最小生成树的算法（普利姆算法，克鲁斯卡尔算法）"><a href="#最小生成树的算法（普利姆算法，克鲁斯卡尔算法）" class="headerlink" title="最小生成树的算法（普利姆算法，克鲁斯卡尔算法）"></a>最小生成树的算法（普利姆算法，克鲁斯卡尔算法）</h1><h2 id="普利姆算法（Prim）"><a href="#普利姆算法（Prim）" class="headerlink" title="普利姆算法（Prim）"></a>普利姆算法（Prim）</h2><p>算法执行过程</p><pre><code class="hljs">将v0到其他顶点的所有边当做候选边重复以下过程，直到所有的顶点被并入树中    1.从候选边中挑选出最小的边输出，并将于该边的另一端顶点并入树中    2.考查所有剩余的顶点，选取与这棵树相接的边最短的边</code></pre><p>时间复杂度为O(n2)，适用于稠密图</p><h2 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h2><p>思路：<br>    每次找出后候选边中权值最小的边，并入生成树中</p><p>算法执行过程</p><pre><code class="hljs">将图中边按照权值从小到大排序，然后从最小边开始扫描，并检测当前边是否为候选边，即是否该边并入会构成回路</code></pre><p>适用于稀疏图</p><h1 id="什么时候最小生成树唯一"><a href="#什么时候最小生成树唯一" class="headerlink" title="什么时候最小生成树唯一"></a>什么时候最小生成树唯一</h1><p>所有权值都不相同，或者有相同的边，但是在构造最小生成树的过程中权值相等的边都被并入到最小生成树中的图，其最小生成树是唯一的。</p><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="Dijkstra算法（迪杰斯特拉）"><a href="#Dijkstra算法（迪杰斯特拉）" class="headerlink" title="Dijkstra算法（迪杰斯特拉）"></a>Dijkstra算法（迪杰斯特拉）</h2><p>迪杰斯特拉算法</p><p>用于计算图中某一结点到其余顶点的最短路径</p><p>思路：</p><pre><code class="hljs">集合s存放图中一找到最短路径的顶点集合U存放途中剩余顶点</code></pre><p>算法步骤：</p><p>算法步骤：</p><p>a.初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U&#x3D;{其余顶点}，若v与U中顶点u有边，则&lt;u,v&gt;正常有权值，若u不是v的出边邻接点，则&lt;u,v&gt;权值为∞。</p><p>b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。</p><p>c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。</p><p>d.重复步骤b和c直到所有顶点都包含在S中。</p><h2 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h2><p>解决任意两点间的最短路径的一种算法，</p><p>可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包</p><p>时间复杂度为O(N3)，空间复杂度为O(N2)。</p><p><strong>算法描述</strong>：</p><p>a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 　　</p><p>b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。</p><h1 id="拓扑排序的概念以及实现"><a href="#拓扑排序的概念以及实现" class="headerlink" title="拓扑排序的概念以及实现"></a>拓扑排序的概念以及实现</h1><p>AOV网</p><p>一种以顶点表示活动，以边表示<strong>活动的先后次序</strong>且<strong>没有回路</strong>的有向图</p><p>反映出整个工程中各个活动之间的先后关系的有向图。</p><p>拓扑算法的核心</p><p>过程：</p><pre><code class="hljs">从有向图中选择一个没有前驱（入读为0）的顶点输出删除1中的顶点，并且删除从该顶点发出的全部边一直重复</code></pre><p>若图中没有环的时候，还可采用深度优先搜索遍历的方法进行拓扑排序</p><h1 id="关键路径的相关概念"><a href="#关键路径的相关概念" class="headerlink" title="关键路径的相关概念"></a>关键路径的相关概念</h1><p>AOE网——对于活动在<strong>边</strong>上的我网</p><p>AOV和AOE的区别</p><p>相同点: 都是无环图</p><p>不同点：AOV活动在顶点，边无权值，代表活动之前的先后关系，<br>                AOE活动在边，边有权值，代表活动持续的时间</p><p>关键路径的核心算法：</p><p><strong>最大路径长度的路径称为关键路径</strong></p><p>关键活动：关键路径上的活动为关键路径，关键活动的最早开始时间等于最晚开始时间。由于AOE网中的某些活动是可以同时发生的，所以完成整个工程的时间应该是从始点到终点的最大路径长度，关键路径长度即为工程的最短完成时间。</p><h1 id="各种排序的概括与总结"><a href="#各种排序的概括与总结" class="headerlink" title="各种排序的概括与总结"></a>各种排序的概括与总结</h1><p><img src="https://img-blog.csdnimg.cn/20200506173421805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE3NzU5NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200512134258944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE3NzU5NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>经过一趟排序，能保证一个关键字到达最终位置</strong><br>    冒泡排序、快速排序（交换类）<br>    简单选择、堆排序（选择类）</p><p><strong>关键字比较次数和原始序列无关</strong><br>    简单选择、折半排序</p><p><strong>排序趟数和原始序列无关</strong><br>    冒泡排序、快速排序（交换类）</p><p><strong>将顺序存储更换为链式存储，时间效率低</strong><br>    希尔排序、堆排序</p><p><strong>排序最优和最差相同的排序算法</strong><br>    简单选择、归并排序、堆排序</p><p><strong>排序算法中那些最坏和平均的时间复杂度是一样的</strong><br>    直接插入、折半插入、冒泡排序、简单选择、堆排序、归并排序</p><p><strong>稳定排序算法</strong><br>直接插入排序，冒泡排序和归并排序。</p><h1 id="各种查找方法"><a href="#各种查找方法" class="headerlink" title="各种查找方法"></a>各种查找方法</h1><p>查找方法分为静态查找表和动态查找表</p><p>静态查找表：顺序查找、折半查找、分块查找</p><p>动态查找表：二叉排序树、平衡二叉树</p><p>顺序查找：结构简单，顺序结构和链式结构都可以，查找效率低</p><p>折半查找：要求查找表为顺序存储结构并且有序</p><p>分块查找：先把查找表分为若干子表，要求每个子表的元素都要比他后面的子表的元素小，从而保存块间是有序的，把各子表中的最大关键词构成一张索引表，表中还包含各子表的起始地址。<br>特点：块间有序，块内无序，查找时块间进行索引查找，块内进行顺序查找。</p><p>二叉排序树：</p><p>平衡二叉树：他的左右子树高度差不能大于1，且左右子树也都是平衡二叉树。</p><h1 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h1><p>优化：<br>1.当整个序列有序时退出算法；<br>2.当序列长度很小时（根据经验是大概小于 8），应该使用常数更小的算法，比如插入排序等；<br>3.随机选取分割位置；<br>4.当分割位置不理想时，考虑是否重新选取分割位置；<br>5.分割成两个序列时，只对其中一个递归进去，另一个序列仍可以在这一函数内继续划分，可以显著减小栈的大小（尾递归）：<br>6.将单向扫描改成双向扫描，可以减少划分过程中的交换次数</p><p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序<br>原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</p><p>优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</p><p>优化3：优化递归操作<br>快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化</p><p>优点：如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。优化后，可以缩减堆栈深度，由原来的O(n)缩减为O(logn)，将会提高性能。</p><h1 id="B树和B-树的区别，以一个m阶数为例"><a href="#B树和B-树的区别，以一个m阶数为例" class="headerlink" title="B树和B+树的区别，以一个m阶数为例"></a>B树和B+树的区别，以一个m阶数为例</h1><p>&#x3D;&#x3D;关键词的数量不同&#x3D;&#x3D;：<br>B+树中具有n个关键字的结点只含有n棵子树。每个结点关键字个数的范围是|m&#x2F;2| &lt;&#x3D; n &lt;&#x3D; m<br>B树中具有n个关键字的结点含有n+1棵子树。每个结点关键字个数的范围是|m&#x2F;2| -1&lt;&#x3D; n &lt;&#x3D; m-1</p><p>&#x3D;&#x3D;存储的位置不同&#x3D;&#x3D;：B+树中数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中。</p><p>&#x3D;&#x3D;分支结点的结构不同&#x3D;&#x3D;：B+树的分支结点仅仅存储着关键字信息和儿子的指针，也就是说内部结点仅仅包含着索引信息</p><p>&#x3D;&#x3D;查询不同&#x3D;&#x3D;：B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束。</p><p><img src="https://img-blog.csdnimg.cn/20200507151335238.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020050715134813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE3NzU5NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="哈希表（概念、构造方法、冲突解决）"><a href="#哈希表（概念、构造方法、冲突解决）" class="headerlink" title="哈希表（概念、构造方法、冲突解决）"></a>哈希表（概念、构造方法、冲突解决）</h1><p><strong>概念</strong>：根据给定的关键字来计算出关键字的表内地址</p><h2 id="建立方法"><a href="#建立方法" class="headerlink" title="建立方法"></a>建立方法</h2><p>直接定址法：<br>    H(Key)&#x3D;a*Key+b<br>    特点：计算简单，且不会产生冲突，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</p><p>数字分析法：<br>    适用于关键字位数比较多且标红可能的关键字都是已知的情况</p><p>平方取中法：<br>    取关键字平方后的中间几位作为Hash地址<br>    适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数</p><p>除留余数法：</p><h2 id="冲突解决方法"><a href="#冲突解决方法" class="headerlink" title="冲突解决方法"></a>冲突解决方法</h2><p><strong>1.开放定址法</strong><br>    线性探查法：依次探查下一个地址，直到有空位置出现为止（容易产生堆积）<br>    平方探查法：可以减少堆积问题，但是不能探查到hash上的所有单元，可探查到一半单元。</p><p><strong>2.链地址法</strong><br>    把所有的同义词用单链表连接起来</p><p><strong>3.公共溢出区</strong></p><h1 id="用循环比递归的效率高吗？"><a href="#用循环比递归的效率高吗？" class="headerlink" title="用循环比递归的效率高吗？"></a>用循环比递归的效率高吗？</h1><p>递归和循环两者完全可以互换。不能完全决定性地说循环地效率比递归的效率高。</p><p><strong>递归算法</strong></p><p>优点：代码简洁、清晰，并且容易验证正确性。</p><p>缺点：它的运行需要较多次数的函数调用，如果调用<strong>层数</strong>比较深，需要增加额外的堆栈处理（还有可能出现堆栈溢出的情况），比如参数传递需要<strong>压栈</strong>等操作，会对执行效率有一定影响。<br>但是，对于某些问题，如果不使用递归，那将是极端<strong>难看</strong>的代码。在编译器优化后，对于多次调用的函数处理会有非常好的效率优化，效率未必低于循环。</p><p><strong>循环算法</strong></p><p>优点：速度快，结构简单。</p><p>缺点：并不能解决所有的问题。有的问题适合使用递归而不是循环。如果使用循环并不困难的话，最好使用循环。</p><h1 id="贪心算法和动态规划区别？"><a href="#贪心算法和动态规划区别？" class="headerlink" title="贪心算法和动态规划区别？"></a>贪心算法和动态规划区别？</h1><p>贪心算法顾名思义就是做出在当前看来是最好的结果，它不从整体上加以考虑，也就是<strong>局部最优解</strong>。贪心算法<strong>从上往下</strong>，从顶部一步一步最优，的到最后的结果，它不能保证全局最优解，与贪心策略的选择有关。</p><p>   动态规划是把问题分解成子问题，这些子问题可能有重复，可以记录下前面子问题的结果防止重复计算。动态规划解决子问题，前一个子问题的解对后一个子问题产生一定的影响。在求解子问题的过程中保留哪些有可能得到最优的局部解，丢弃其他局部解，直到解决最后一个问题时也就是初始问题的解。动态规划是<strong>从下到上</strong>，一步一步找到<strong>全局最优解</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>面试、复试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【论文阅读】用于自动驾驶的高清地图生成技术</title>
    <link href="/2022/08/26/01.%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0--%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE/"/>
    <url>/2022/08/26/01.%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0--%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="High-Definition-Map-Generation-Technologies-for-Autonomous-Driving"><a href="#High-Definition-Map-Generation-Technologies-for-Autonomous-Driving" class="headerlink" title="High-Definition Map Generation Technologies for Autonomous Driving"></a>High-Definition Map Generation Technologies for Autonomous Driving</h1><blockquote><p>回顾了最近利用2D和3D地图生成的高清地图生成技术。介绍了高清地图的概念及其在自动驾驶中的作用，并对高清地图生成技术进行了详细概述。</p></blockquote><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p><strong>高清地图</strong>包含自动驾驶所需的道路&#x2F;环境的所有关键静态属性（例如：道路、建筑物、交通灯和道路标线），包括由于遮挡而无法由传感器适当检测到的对象。</p><p><strong>三层结构化高清地图示例</strong></p><ol><li>导航数据；HD Road；道路网</li><li>规划数据；HD lanes； 车道地图</li><li>道路DNA；HD Localization；地标&#x2F;道路标记图</li></ol><p>第一层，<strong>道路模型</strong>，定义道路特征，例如拓扑、行驶方向、高程、坡度&#x2F;坡道、规则、路缘&#x2F;边界和十字路口。它用于<code>导航</code>。</p><p>第二层，<strong>车道模型</strong>，定义了车道级别的特征，例如道路类型、线路、道路宽度、停车区域和速度限制。该层用作自动驾驶的感知模块，根据<code>实时交通</code>或环境做出决策。</p><p>最后一层，<strong>定位模型</strong>，在高清地图中定位自动车辆。该层包含路边设施，例如建筑物、交通信号、标志和路面标记。这些功能有助于自动车辆快速定位，尤其是在功能丰富的城市地区。</p><h2 id="高清地图点云的数据收集"><a href="#高清地图点云的数据收集" class="headerlink" title="高清地图点云的数据收集"></a>高清地图点云的数据收集</h2><blockquote><p>数据收集是生成高清地图的第一步</p></blockquote><p>主要依靠：MMS（moblile mapping system—移动地图系统）</p><p>MMS：</p><ul><li>一种配备地图传感器的移动车辆，</li><li>包括<strong>全球导航卫星系统</strong>（GNSS）、<strong>IMU</strong>、激光雷达（光探测和测距）、摄像头和雷达，用于收集地理空间数据。</li></ul><h2 id="点云地图生成方式"><a href="#点云地图生成方式" class="headerlink" title="点云地图生成方式"></a>点云地图生成方式</h2><p>一旦收集到初始传感器数据，通常会对其进行<strong>融合和排序</strong>以生成初始地图，主要用于精确定位。</p><p>点云地图具有很高的精度，可以帮助地面车辆在三维空间中进行厘米级的精确机动和定位。</p><ul><li>从映射中获得点云配准（多步骤过程）：将多个重叠的点云对齐，以生成详细准确的地图</li><li>从PCL映射创建向量映射</li></ul><p>矢量地图包含与车道、人行道、十字路口、道路、十字路口、交通标志和红绿灯相关的信息。</p><p><img src="https://img-blog.csdnimg.cn/afa54ac4895a4675b23333658fe396ad.png"></p><h3 id="A-映射技术"><a href="#A-映射技术" class="headerlink" title="A.映射技术"></a>A.映射技术</h3><ul><li>激光作为主要传感器，用于绘制和完成高清晰度地图。</li><li>用视觉传感器来构建点云地图</li><li>有一种用于三维模型生成的点云注册技术</li></ul><ol><li>基于分割的点云配准<br>SegMap[15]是一种基于点云分段特征提取的映射解决方案。该方法通过将局部特征重构为具有区分性的特征来生成点云地图。<blockquote><p>“SegMap: Segment-based mapping and<br>localization using data-driven descriptors,”  doi: 10.1177&#x2F;0278364919863090. </p></blockquote></li><li>基于激光雷达的点云映射</li><li>里程融合点云配准</li><li>GPS融合点云配准</li><li>INS融合点云配准</li><li>视觉传感器融合点云配准</li></ol><h2 id="高清地图特征提取方式"><a href="#高清地图特征提取方式" class="headerlink" title="高清地图特征提取方式"></a>高清地图特征提取方式</h2><h3 id="道路网络提取"><a href="#道路网络提取" class="headerlink" title="道路网络提取"></a>道路网络提取</h3><h4 id="基于二维航空图像的道路提取"><a href="#基于二维航空图像的道路提取" class="headerlink" title="基于二维航空图像的道路提取"></a>基于二维航空图像的道路提取</h4><ol><li>基于分割的方法<br> 从航空图像中预测分割概率图，细化分割预测并通过后处理提取图形。</li><li>迭代图增长法<br> 迭代图生长方法通过首先选择道路网络的几个顶点，从二维航空图像生成道路网络。然后，逐点生成道路，直到创建整个道路网络。</li><li>图形生成方法</li></ol><h4 id="基于三维点云的道路提取"><a href="#基于三维点云的道路提取" class="headerlink" title="基于三维点云的道路提取"></a>基于三维点云的道路提取</h4><blockquote><p>使用3D点云的道路提取是使用分割完成的。</p></blockquote><p>论文：Creation of high definition map<br>for autonomous driving within specific scene</p><h4 id="基于传感器融合方法的道路-x2F-边界提取"><a href="#基于传感器融合方法的道路-x2F-边界提取" class="headerlink" title="基于传感器融合方法的道路&#x2F;边界提取"></a>基于传感器融合方法的道路&#x2F;边界提取</h4><h2 id="高清地图常用框架"><a href="#高清地图常用框架" class="headerlink" title="高清地图常用框架"></a>高清地图常用框架</h2><h2 id="高清地图生成的局限性"><a href="#高清地图生成的局限性" class="headerlink" title="高清地图生成的局限性"></a>高清地图生成的局限性</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
    <categories>
      
      <category>高精地图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精地图</tag>
      
      <tag>论文笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apollo高精地图</title>
    <link href="/2022/08/26/01.Apollo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <url>/2022/08/26/01.Apollo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h1 id="apollo之高精地图"><a href="#apollo之高精地图" class="headerlink" title="apollo之高精地图"></a>apollo之高精地图</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>apollo的高精度地图采用了opendrive格式，opendrive是一个统一的地图标准，这样保证了地图的通用性。</p><h2 id="apollo之map模块"><a href="#apollo之map模块" class="headerlink" title="apollo之map模块"></a>apollo之map模块</h2><p>代码目录结构：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk">├── data           <span class="hljs-regexp">//</span> 生成好的地图<br>│   └── demo<br>├── hdmap          <span class="hljs-regexp">//</span> 高精度地图<br>│   ├── adapter    <span class="hljs-regexp">//</span> 从xml文件读取地图(opendrive保存格式为xml)<br>│   │   └── xml_parser<br>│   └── test-data<br>├── pnc_map        <span class="hljs-regexp">//</span> 给规划控制模块用的地图<br>│   └── testdata<br>├── proto          <span class="hljs-regexp">//</span> 地图各元素的消息格式(人行横道，车道线等)<br>├── relative_map   <span class="hljs-regexp">//</span> 相对地图<br>│   ├── common<br>│   ├── conf<br>│   ├── dag<br>│   ├── launch<br>│   ├── proto<br>│   ├── testdata<br>│   │   └── multi_lane_map<br>│   └── tools<br>├── testdata       <span class="hljs-regexp">//</span> 测试数据？<br>│   └── navigation_dummy<br>└── tools          <span class="hljs-regexp">//</span> 工具<br></code></pre></td></tr></table></figure><h2 id="apollo-高精地图"><a href="#apollo-高精地图" class="headerlink" title="apollo 高精地图"></a>apollo 高精地图</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map()"></a>Map()</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Header</span> &#123;<br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">bytes</span> version = <span class="hljs-number">1</span>;   <span class="hljs-comment">//地图版本</span><br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">bytes</span> date = <span class="hljs-number">2</span>;      <span class="hljs-comment">//地图时间</span><br>  <span class="hljs-keyword">optional</span> Projection projection = <span class="hljs-number">3</span>; <span class="hljs-comment">//投影方法</span><br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">bytes</span> district = <span class="hljs-number">4</span>;        <span class="hljs-comment">//区</span><br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">bytes</span> generation = <span class="hljs-number">5</span>;      <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">bytes</span> rev_major = <span class="hljs-number">6</span>;       <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">bytes</span> rev_minor = <span class="hljs-number">7</span>;       <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">double</span> left = <span class="hljs-number">8</span>;           <span class="hljs-comment">//左</span><br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">double</span> top = <span class="hljs-number">9</span>;            <span class="hljs-comment">//上</span><br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">double</span> right = <span class="hljs-number">10</span>;         <span class="hljs-comment">//右</span><br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">double</span> bottom = <span class="hljs-number">11</span>;        <span class="hljs-comment">//底</span><br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">bytes</span> vendor = <span class="hljs-number">12</span>;         <span class="hljs-comment">//供应商</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Lane"><a href="#Lane" class="headerlink" title="Lane()"></a>Lane()</h3><p>车道结构：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Lane</span> &#123;<br>  <span class="hljs-keyword">optional</span> Id id = <span class="hljs-number">1</span>;         <span class="hljs-comment">//编号</span><br>  <span class="hljs-keyword">optional</span> Curve central_curve = <span class="hljs-number">2</span>;     <span class="hljs-comment">//中心曲线</span><br>  <span class="hljs-keyword">optional</span> LaneBoundary left_boundary = <span class="hljs-number">3</span>;          <span class="hljs-comment">//左边界</span><br>  <span class="hljs-keyword">optional</span> LaneBoundary right_boundary = <span class="hljs-number">4</span>;         <span class="hljs-comment">//右边界</span><br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">double</span> length = <span class="hljs-number">5</span>;                       <span class="hljs-comment">//长度</span><br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">double</span> speed_limit = <span class="hljs-number">6</span>;           <span class="hljs-comment">//速度限制</span><br>  <span class="hljs-keyword">repeated</span> Id overlap_id = <span class="hljs-number">7</span>;                <span class="hljs-comment">//重叠区域id</span><br>  <br>  <span class="hljs-keyword">repeated</span> Id predecessor_id = <span class="hljs-number">8</span>;           <span class="hljs-comment">//前任id</span><br>  <span class="hljs-keyword">repeated</span> Id successor_id = <span class="hljs-number">9</span>;             <span class="hljs-comment">//继任者id</span><br><br> <br>  <span class="hljs-keyword">repeated</span> Id left_neighbor_forward_lane_id = <span class="hljs-number">10</span>;    <span class="hljs-comment">//左边相邻前方车道id</span><br>  <span class="hljs-keyword">repeated</span> Id right_neighbor_forward_lane_id = <span class="hljs-number">11</span>;   <span class="hljs-comment">//右边相邻前方车道id</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">enum LaneType &#123;               <span class="hljs-regexp">//</span>车道类型<br>  NONE = <span class="hljs-number">1</span>;                  <span class="hljs-regexp">//</span>无<br>  CITY_DRIVING = <span class="hljs-number">2</span>;           <span class="hljs-regexp">//</span>城市道路<br>  BIKING = <span class="hljs-number">3</span>;                 <span class="hljs-regexp">//</span>自行车<br>  SIDEWALK = <span class="hljs-number">4</span>;               <span class="hljs-regexp">//</span>人行道<br>  PARKING = <span class="hljs-number">5</span>;                <span class="hljs-regexp">//</span>停车<br>&#125;;<br>optional LaneType type = <span class="hljs-number">12</span>;         <span class="hljs-regexp">//</span>车道类型<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">enum LaneTurn &#123;<br>  NO_TURN <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;        //直行</span><br>  LEFT_TURN <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;      //左转弯</span><br>  RIGHT_TURN <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-comment">;     //右转弯</span><br>  U_TURN <span class="hljs-operator">=</span> <span class="hljs-number">4</span><span class="hljs-comment">;         //掉头</span><br>&#125;<span class="hljs-comment">;</span><br>optional LaneTurn turn <span class="hljs-operator">=</span> <span class="hljs-number">13</span><span class="hljs-comment">;          //转弯类型</span><br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">repeated Id left_neighbor_reverse_lane_id <span class="hljs-operator">=</span> <span class="hljs-number">14</span><span class="hljs-comment">;       //左边相邻反方向车道id</span><br>repeated Id right_neighbor_reverse_lane_id <span class="hljs-operator">=</span> <span class="hljs-number">15</span><span class="hljs-comment">;      //右边相邻反方向车道id</span><br><br>optional Id junction_id <span class="hljs-operator">=</span> <span class="hljs-number">16</span><span class="hljs-comment">;</span><br><br>repeated LaneSampleAssociation left_sample <span class="hljs-operator">=</span> <span class="hljs-number">17</span><span class="hljs-comment">;      //中心点与最近左边界之间的关联</span><br>repeated LaneSampleAssociation right_sample <span class="hljs-operator">=</span> <span class="hljs-number">18</span><span class="hljs-comment">;     //中心点与最近右边界之间的关联</span><br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">  enum LaneDirection &#123;<br>    FORWARD <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;     //前</span><br>    BACKWARD <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;    //后，潮汐车道借用的情况？</span><br>    BIDIRECTION <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-comment">;  //双向</span><br>  &#125;<br>  optional LaneDirection direction <span class="hljs-operator">=</span> <span class="hljs-number">19</span><span class="hljs-comment">;   //车道方向</span><br> <br>  repeated LaneSampleAssociation left_road_sample <span class="hljs-operator">=</span> <span class="hljs-number">20</span><span class="hljs-comment">;    //中心点与最近左路边界之间的关联</span><br>  repeated LaneSampleAssociation right_road_sample <span class="hljs-operator">=</span> <span class="hljs-number">21</span><span class="hljs-comment">;    //中心点与最近右路边界之间的关联</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Road"><a href="#Road" class="headerlink" title="Road()"></a>Road()</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">RoadSection</span> &#123;<br>  <span class="hljs-keyword">optional</span> Id id = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 本节所包含的车道</span><br>  <span class="hljs-keyword">repeated</span> Id lane_id = <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// 截面边界</span><br>  <span class="hljs-keyword">optional</span> RoadBoundary boundary = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-comment">// 道路是车道、道路边界等交通要素的集合。</span><br><span class="hljs-comment">// 它提供道路的一般信息。</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Road</span> &#123;<br>  <span class="hljs-keyword">optional</span> Id id = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">repeated</span> RoadSection section = <span class="hljs-number">2</span>;<br><br>  <span class="hljs-comment">// 如果车道不在路口，路口id为空。</span><br>  <span class="hljs-keyword">optional</span> Id junction_id = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="具体生成方法"><a href="#具体生成方法" class="headerlink" title="具体生成方法"></a>具体生成方法</h1><h2 id="确保在docker容器中"><a href="#确保在docker容器中" class="headerlink" title="确保在docker容器中"></a>确保在docker容器中</h2><p>先进入apollo目录下</p><h3 id="1-启动docker"><a href="#1-启动docker" class="headerlink" title="1. 启动docker"></a>1. 启动docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash docker/scripts/dev_start.sh<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/818608576b6b4bdeae5885567b3bac7e.png" alt="在这里插入图片描述"></p><h3 id="2-开始docker"><a href="#2-开始docker" class="headerlink" title="2. 开始docker"></a>2. 开始docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash docker/scripts/dev_into.sh<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/94bb5069221646bc8a3df866794f3709.png" alt="在这里插入图片描述"></p><h3 id="3-在docker中编译apollo源码"><a href="#3-在docker中编译apollo源码" class="headerlink" title="3. 在docker中编译apollo源码"></a>3. 在docker中编译apollo源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash apollo.sh build_cpu<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/696bb1478d6f47afb818c25474489764.png" alt="在这里插入图片描述"></p><h3 id="启动DreamView"><a href="#启动DreamView" class="headerlink" title="启动DreamView"></a>启动DreamView</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./scripts/bootstrap.sh [start | stop | restart]<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2d4e830f233c41dd87e322c532f6ac04.png" alt="在这里插入图片描述"></p><h3 id="打开浏览器"><a href="#打开浏览器" class="headerlink" title="打开浏览器"></a>打开浏览器</h3><p>：<a href="http://localhost:8888/">http://localhost:8888/</a></p><p><img src="https://img-blog.csdnimg.cn/9ba0287f111e45e689571d81f4509853.png" alt="在这里插入图片描述"></p><h3 id="下载预录资源"><a href="#下载预录资源" class="headerlink" title="下载预录资源"></a>下载预录资源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 rosbag_helper.py demo_3.5.record<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3ec341c4c99f4c34914930a28976d662.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cyber_recorder play -f demo_3.5.record -l<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/1b27c60dbeee45c196baefee510cf2aa.png" alt="在这里插入图片描述"><br>界面显示如图<br><img src="https://img-blog.csdnimg.cn/dc5a67ef7a954d31a48c9ffc426ae8b9.png" alt="在这里插入图片描述"></p><h2 id="生成好的地图"><a href="#生成好的地图" class="headerlink" title="生成好的地图"></a>生成好的地图</h2><p><a href="https://zhuanlan.zhihu.com/p/358796415">参考</a></p><h3 id="查看当前轨迹"><a href="#查看当前轨迹" class="headerlink" title="查看当前轨迹"></a>查看当前轨迹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python modules/tools/map_gen/plot_path.py test.csv<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0d417740fc0b47b98e89ad84db15804a.png" alt="在这里插入图片描述"></p><h3 id="生成地图"><a href="#生成地图" class="headerlink" title="生成地图"></a>生成地图</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python modules/tools/map_gen/map_gen.py points <br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6875f8eac3bc4c26b479fd7d813a4bfa.png" alt="在这里插入图片描述"><br>得到<br><img src="https://img-blog.csdnimg.cn/07f6fee26b924139b4232f09de62f0bb.png" alt="在这里插入图片描述"></p><h3 id="查看地图"><a href="#查看地图" class="headerlink" title="查看地图"></a>查看地图</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python modules/tools/mapshow/mapshow.py -m map_test.csv.txt<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/73bb6886add045b98bd51f491aaf4b26.png" alt="在这里插入图片描述"></p><h3 id="apollo-地图生成"><a href="#apollo-地图生成" class="headerlink" title="apollo 地图生成"></a>apollo 地图生成</h3><h4 id="base-map-bin"><a href="#base-map-bin" class="headerlink" title="base_map.bin"></a>base_map.bin</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python modules/tools/create_map/convert_map_txt2bin.py -i mymap/map_test.csv.txt -o mymap/base_map.bin <br></code></pre></td></tr></table></figure><p>-o:存放路径</p><p><img src="https://img-blog.csdnimg.cn/69619e7b22024eb3943ce107eeb38cb3.png" alt="在这里插入图片描述"></p><h4 id="sim-map-bin"><a href="#sim-map-bin" class="headerlink" title="sim_map.bin"></a>sim_map.bin</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bazel-bin/modules/map/tools/sim_map_generator -map_dir=mymap/ -output_dir=mymap/ <br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/456fbcc079394c16aa05a1a0d1d9aa4b.png" alt="在这里插入图片描述"></p><h4 id="routing-map-bin"><a href="#routing-map-bin" class="headerlink" title="routing_map.bin"></a>routing_map.bin</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bazel-bin/modules/routing/topo_creator/topo_creator -map_dir=mymap/ --flagfile=modules/routing/conf/routing.conf<br></code></pre></td></tr></table></figure><h2 id="生成地图另外一种方法"><a href="#生成地图另外一种方法" class="headerlink" title="生成地图另外一种方法"></a>生成地图另外一种方法</h2><p><a href="https://blog.csdn.net/weixin_49024732/article/details/118862027?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165992214716781647593804%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165992214716781647593804&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-118862027-null-null.142%5Ev39%5Epc_rank_34_queryrelevant0,185%5Ev2%5Econtrol&utm_term=Apollo%20map_gen&spm=1018.2226.3001.4187">参考</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash /apollo/scripts/create_map_from_xy.sh --xy  test.csv --map_name <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/apollo/bazel-bin/modules/map/tools/bin_map_generator --map_dir=/apollo/modules/map/data/test --output_dir=/apollo/modules/map/data/test<br></code></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="linux-文件解锁"><a href="#linux-文件解锁" class="headerlink" title="linux 文件解锁"></a>linux 文件解锁</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> -R 777 路径<br></code></pre></td></tr></table></figure><h3 id="pip-install-豆瓣源"><a href="#pip-install-豆瓣源" class="headerlink" title="pip install 豆瓣源"></a>pip install 豆瓣源</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pyinstaller -i http://pypi.douban.com/simple --trusted-host pypi.douban.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>高精地图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精地图</tag>
      
      <tag>apollo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apollo初步了解</title>
    <link href="/2022/08/26/01.Apollo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2022/08/26/01.Apollo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote><p>apollo是百度的自动驾驶开源框架，根据自动驾驶的功能划分为不同的模块.</p></blockquote><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>github地址：<a href="https://github.com/ApolloAuto/apollo">Apollo</a></p><p><img src="https://img-blog.csdnimg.cn/e1626a9daee2415a8610e5c9b3923e8e.png" alt="Apollo基本构架"></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs smali">cyber  消息中间件，替换ros作为消息层<br>docker 容器相关<br>docs 文档相关<br>modules 自动驾驶模块，主要的定位，预测，感知，规划都在这里<br>calibration   校准，主要用于传感器坐标的校准，用于感知模块做传感器融合<br>canbus   通讯总线，工业领域的标准总线，鉴于工业界的保守，我估计后面会有新的总线来取代<br>common  <br>contrib   <br>control   控制模块，根据planning生成的路径对车辆轨迹进行控制，<br>          再底层就是发送命令到can总线，实现车辆的控制。<br>data  地图等生成好的数据放在这里（其他数据待补充）<br>dreamview  仿真，能够对自动驾驶过程中的数据进行回放，其他厂家也有推出一些仿真平台，<br>           后面有机会再介绍下<br>drivers  雷达，lidar，GPS, canbus，camera等驱动<br>guardian  监护程序？<br>localization  定位，获取汽车的当前位置<br>map  地图模块<span class="hljs-built_in"></span><br><span class="hljs-built_in">monitor </span> 监控模块，主要是监控汽车状态，并且记录，用于故障定位，健康检查等<br>perception 感知，获取汽车当前的环境，行人，车辆，红绿灯等，给planning模块规划线路<br>planning  规划，针对感知到的情况，对路径做规划，短期规划，只规划100-200M的距离，<br>          生成好的路径给control模块<br>prediction 预测，属于感知模块，对运动物体的轨迹做预测<br>routing  导航线路，就是百度地图上查询2点之间的线路，生成的线路短期规划还是planning模块<br>third_party_perception 第三方感知模块<br>tools 工具，这里面的工具倒是很多，后面再详细介绍下<br>transform 转换，主要是？<br>v2x 顾名思义就vehicle-to-everything，其希望实现车辆与一切可能影响车辆的实体实现信息交互，<br>    目的是减少事故发生，减缓交通拥堵，降低环境污染以及提供其他信息服务.<br>scripts 脚本<br>third_party 第三方库<br>tools 工具目录，基本就是个空目录<br></code></pre></td></tr></table></figure><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><code>Docker</code>是一种容器的技术，它在是Linux内核的基础上做了一些轻量级和隔离机制的优化，让环境更小，部署起来更快。利用Docker可以使整个工程的安装更加简单。Docker镜像通常是一个配置好的运行环境，包括依赖的第三方库等，使得用户不需要对环境编译做过多复杂的操作。例如，在Release版本中，Apollo各个模块是一个已经编译好的二进制文件，可以直接运行；如果是开发版本，通常已经加载了所需的第三方库，用户只需要执行对应的编译指令。</p><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><ul><li>第一阶段是在<code>Ubuntu</code>环境下进行操作，包括下载Apollo源码，安装<code>Docker</code>。Docker的安装方式有在线和离线两种方式，大家可以根据网络环境选取合适的安装方式。</li><li>第二阶段是进入<code>Docker</code>，拉取Apollo镜像，并以此镜像创建容器。</li><li>第三个阶段是进入创建的容器，编译<code>Apollo</code>源码。</li></ul>]]></content>
    
    
    <categories>
      
      <category>高精地图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精地图</tag>
      
      <tag>apollo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精地图制作1</title>
    <link href="/2022/08/25/01.%E9%AB%98%E7%B2%BE%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C1/"/>
    <url>/2022/08/25/01.%E9%AB%98%E7%B2%BE%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-高精地图简介"><a href="#1-高精地图简介" class="headerlink" title="1. 高精地图简介"></a>1. 高精地图简介</h1><h2 id="1-1-高精地图介绍"><a href="#1-1-高精地图介绍" class="headerlink" title="1.1 高精地图介绍"></a>1.1 高精地图介绍</h2><p>高精地图即为“两高一多”的地图，在自动驾驶中常常被称为HapMap，这是自动驾驶汽车中非常重要的一部分</p><ul><li><strong>高精度</strong>：精度可以达到厘米级别</li><li><strong>高动态</strong>：高精地图实时性，为了应对各类突发状况，自动驾驶车辆需要高精地图的数据具有较好的实时性</li><li><strong>多维度</strong>：地图中不仅包含有详细的车道模型、道路部件信息，还包含与交通安全相关的一些道路属性信息，例如GPS信号消失的区域、道路施工状态等</li></ul><h2 id="1-2-传统制作流程"><a href="#1-2-传统制作流程" class="headerlink" title="1.2 传统制作流程"></a>1.2 传统制作流程</h2><blockquote><p>采集、加工、转换</p></blockquote><h3 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h3><p>需要一些传感器来获取数据，下面是需要的传感器列表：</p><ul><li>lidar、摄像头、gnss、imu</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">lidar主要是来采集点云数据，因为激光雷达可以精确的反应出位置信息，所以激光雷达可以知道路面的宽度，红绿灯的高度，以及一些其他的信息，当然现在也有厂家基于视觉SLAM（纯摄像头测距）来制作地图的，有兴趣的也可以看下相关介绍。<br>摄像头主要是来采集一些路面的标志，车道线等，因为图像的像素信息更多，而位置信息不太精确，所以采用摄像头来识别车道线，路面的一些标志等。<br>gnss记录了车辆的位置信息，记录了当前采集点的坐标。<br>imu用来捕获车辆的角度和加速度信息，用来校正车辆的位置和角度。<br></code></pre></td></tr></table></figure><h3 id="加工"><a href="#加工" class="headerlink" title="加工"></a>加工</h3><p>对于采集到的点云数据需要进行加工生成点云地图。</p><p>主要算法：</p><ul><li>ICP</li><li>NDT</li></ul><p>基于以上算法把点云姿态进行融合。</p><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><blockquote><p>点云地图校准 -&gt; 地图标注加工 -&gt; 高精度地图</p></blockquote><p>高精地图的图层：</p><ol><li><strong>地图图层</strong> 地图图层主要是道路的信息，比如道路的路沿，车道线，路口信息，主要是道路的一些基本信息。</li><li><strong>定位图层</strong> 定位图层主要是具备独特的目标或特征，比如红绿灯，交通标志，道路的点云数据等。</li><li><strong>动态图层</strong> 动态图层主要是一些实时路况，修路或者封路等需要实时推送或者更新的数据。</li></ol><p>对于生成的高精地图，需要转换成为通用的自动驾驶系统可以使用的高精度地图。</p><ul><li>apollo</li><li>opendrive</li><li>等等</li></ul><h2 id="1-3-自动驾驶地图框架"><a href="#1-3-自动驾驶地图框架" class="headerlink" title="1.3 自动驾驶地图框架"></a>1.3 自动驾驶地图框架</h2><h3 id="1-3-1-Apollo-OpenDrive（百度）"><a href="#1-3-1-Apollo-OpenDrive（百度）" class="headerlink" title="1.3.1 Apollo OpenDrive（百度）"></a>1.3.1 Apollo OpenDrive（百度）</h3><p><img src="https://img-blog.csdnimg.cn/d70a61fd1007496db83782d978bc7ee5.png" alt="Apollo"></p><h3 id="1-3-2-Lanelet2（Autoware）"><a href="#1-3-2-Lanelet2（Autoware）" class="headerlink" title="1.3.2 Lanelet2（Autoware）"></a>1.3.2 Lanelet2（Autoware）</h3><h1 id="2-高精地图制作流程"><a href="#2-高精地图制作流程" class="headerlink" title="2. 高精地图制作流程"></a>2. 高精地图制作流程</h1><p>高精地图是一种语义地图，概括地说，就是利用<code>SLAM/SFM</code>等算法融合多种传感器数据，构建高精度的三维点云地图，在点云地图上或者是图像上，对所用到的元素进行分类和提取、之后对不同元素分别进行矢量化并构建路网与车道关联关系，最后进行质量校验，形成一套地图引擎来存储并支撑其他模块的需求。</p><h2 id="方法一：手动标注"><a href="#方法一：手动标注" class="headerlink" title="方法一：手动标注"></a>方法一：手动标注</h2><p>大致思路：</p><ol><li>生成一张点云地图（已有）</li><li>采取手工标注点云地图的方法来制图</li></ol><p>一些手工标注工具：</p><ul><li><code>RoadRunner</code> (推荐，功能比较齐全)</li><li><code>LGSVL Map Annotation</code>（windows Unity 插件版，需要手动编译）</li><li><code>Autocore MapToolBox</code>插件</li><li><code>Assure mapping tools</code></li><li>51VR、四维图新等高精地图地图服务提供商（收费）</li></ul><h2 id="方法二：自己写代码"><a href="#方法二：自己写代码" class="headerlink" title="方法二：自己写代码"></a>方法二：自己写代码</h2><p>针对于只要道路的高精地图（铁路、隧道）</p><ul><li>Apollo：map_gen工具</li></ul><p> 一些参考：<br> <a href="https://zhuanlan.zhihu.com/p/57958859">王方浩—高精地图制作</a><br> <a href="https://www.cxybb.com/article/lovely_yoshino/117442162">自动驾驶高精地图调研</a> </p>]]></content>
    
    
    <categories>
      
      <category>高精地图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精地图</tag>
      
      <tag>opendrive</tag>
      
      <tag>点云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Opendrive 学习笔记</title>
    <link href="/2022/08/25/01.Opendrive/"/>
    <url>/2022/08/25/01.Opendrive/</url>
    
    <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><code>OpenDRIVE格式使用文件拓展名为xodr的可扩展标记语言（XML）作为描述路网的基础。</code></p><p>存储在OpenDRIVE文件中的数据描述了<strong>道路的几何形状</strong>以及可影响路网逻辑的<strong>相关特征</strong>(features)，例如车道和标志</p><p>该格式将通过节点(nodes)而被构建，用户可通过自定义的数据扩展节点。</p><h1 id="Opendrive坐标系"><a href="#Opendrive坐标系" class="headerlink" title="Opendrive坐标系"></a>Opendrive坐标系</h1><ul><li>xy惯性坐标系</li><li>st参数坐标系</li><li>uv局部坐标系</li></ul><p><img src="https://img-blog.csdnimg.cn/010c48059dba4d71a7820c833c8fe32a.png" alt="在这里插入图片描述"><br><strong>惯性坐标系</strong></p><ul><li>X轴—东，Y轴—北</li><li>弧度关系为X轴为0 逆时针为正（-pi, pi），Y轴为pi&#x2F;2。</li></ul><p><strong>st坐标系</strong></p><ul><li>st坐标系的走势就是从参考线开始到参考线结束一直沿着参考线的<strong>切线</strong>方向进行的</li><li>st坐标系是针对于参考线来说的，只有同一条参考线为基准下才能比较两个点的st坐标。</li><li>S取值范围[0, 参考线长度length]</li><li>T为基于参考线的偏移，使用处于参考线上的点t值均为0</li><li><img src="https://img-blog.csdnimg.cn/42f7c5b90b6f4ce9b302dee4cee5eb8c.png" alt="在这里插入图片描述"></li></ul><h1 id="描述属性"><a href="#描述属性" class="headerlink" title="描述属性"></a>描述属性</h1><h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>（元素很多，但是很多元素也很少用到）<br><img src="https://img-blog.csdnimg.cn/59ef324217b64393bce23d6015d22fd6.png" alt="在这里插入图片描述"><br>总体分为：</p><ul><li>Header类</li><li>Roads类</li><li>Juction类</li></ul><h3 id="Header类"><a href="#Header类" class="headerlink" title="Header类"></a>Header类</h3><p><strong>geoReference</strong> — 规定了整个Opendrive地图的投影方式</p><h3 id="Roads类"><a href="#Roads类" class="headerlink" title="Roads类"></a>Roads类</h3><p>包含所有地图中描述了的道路，每一条道路被一对road标签表示</p><p><img src="https://img-blog.csdnimg.cn/98ebf933cede47798879de7734ebaaf0.png" alt="在这里插入图片描述"></p><p>Road元素：</p><ul><li>link</li><li>planView — 道路参考线（主要）</li><li>lateralProfile — 超高程（从数学角度被定义为围绕参考线的道路横截面的倾斜角。）</li><li>elevationProfile — 高程</li><li>lanes</li><li>type — 道路类型</li><li>surface<br><img src="https://img-blog.csdnimg.cn/e64e3a654f094585bec3885f88c877be.png" alt="在这里插入图片描述"></li></ul><h4 id="road自身属性"><a href="#road自身属性" class="headerlink" title="road自身属性"></a>road自身属性</h4><p><img src="https://img-blog.csdnimg.cn/ed04052f14d34c0eb83a9efa1fed7b1d.png" alt="在这里插入图片描述"></p><ul><li>name道路名称（非必要</li><li>length道路的总长度</li><li>id 道路的唯一属性</li><li>junction — 是否属于道路的唯一属性（道路关系的集合，处理复炸道路连接情况）</li></ul><h4 id="参考线"><a href="#参考线" class="headerlink" title="参考线"></a>参考线</h4><p><img src="https://img-blog.csdnimg.cn/d8ec4d8ce0764b3b84137a72a47a1b18.png" alt="在这里插入图片描述"><br><strong>重要：</strong></p><ul><li>一条道路只能有一条参考线</li><li>一条参考线可以由多条几何线构成</li></ul><p><strong>几何线：</strong></p><ul><li>使用几何线来表示参考线</li><li>分段来描述一条道路的走势</li></ul><p><strong>几何线包含：</strong></p><ol><li>直线 <code>&lt;line&gt;</code></li><li>螺旋线 <code>&lt;spiral&gt;</code></li><li>弧线<code>&lt;arc&gt;</code></li></ol><p>举例表示参考线和几何线在opendrive中式如何表示的：<br><img src="https://img-blog.csdnimg.cn/d47c1ac00a094f7aa46e39dd98b38163.png" alt="在这里插入图片描述"><br><strong>直线 — line:</strong></p><ul><li>s — 起始位置</li><li>x 、 y — 惯性坐标系</li><li>hdg — 给出起始朝向，用弧度表示</li><li>length — 几何线长度</li></ul><p><img src="https://img-blog.csdnimg.cn/9012e8a3dcd54448ae8b3f285c7e4ff0.png" alt="在这里插入图片描述"><br><strong>弧线 — arc</strong></p><ul><li>在直线基础上+curvature弧度</li></ul><p><strong>螺旋线 — spiral</strong></p><ul><li>弧度线性变化的曲线</li><li>curvStart 线性变化起始点</li><li>curvEnd 线性变化的终止点</li></ul><h4 id="link"><a href="#link" class="headerlink" title="link"></a>link</h4><p><code>道路连接</code></p><ul><li>Successor — 前驱</li><li>predecessor — 后继</li></ul><p>示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;link&gt;<br>     &lt;predecessor elementId<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> contactPoint<span class="hljs-operator">=</span><span class="hljs-string">&quot;end&quot;</span> elementType<span class="hljs-operator">=</span><span class="hljs-string">&quot;road&quot;</span>/&gt;<br>     &lt;successor elementId<span class="hljs-operator">=</span><span class="hljs-string">&quot;1&quot;</span> contactPoint<span class="hljs-operator">=</span><span class="hljs-string">&quot;start&quot;</span> elementType<span class="hljs-operator">=</span><span class="hljs-string">&quot;road&quot;</span>/&gt;<br>&lt;/link&gt;<br></code></pre></td></tr></table></figure><p><strong>组合曲线</strong><br><img src="https://img-blog.csdnimg.cn/fcc0158557d0413b82cfd6df0945d095.png" alt="在这里插入图片描述"></p><h4 id="elevationProfile-—-高程元素"><a href="#elevationProfile-—-高程元素" class="headerlink" title="elevationProfile — 高程元素"></a>elevationProfile — 高程元素</h4><p>在OpenDRIVE中，高程Road elevation 用 <code>&lt;elevationProfile&gt;</code> 元素中的 <code>&lt;elevation&gt;</code> 元素来表示。</p><p>该属性定义了参考线上给定点处的高程元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">表达式：elev(ds) = a + b*ds + c*ds² + d*ds³<br></code></pre></td></tr></table></figure><h4 id="lateralProfile-—-超高程元素"><a href="#lateralProfile-—-超高程元素" class="headerlink" title="lateralProfile — 超高程元素"></a>lateralProfile — 超高程元素</h4><p>在OpenDRIVE中，超高程用<code>&lt;lateralProfile&gt;</code>元素中的 <code>&lt;superelevation&gt;</code> 元素来表示横向。</p><p>超高程从数学角度被定义为<strong>围绕参考线的道路横截面的倾斜角</strong>。这意味着超高程对于向右边倾斜的道路具有正值，对于向左边倾斜的道路具有负值。</p><p>该属性被定义为围绕着s轴的路段倾斜角。必须（must）沿参考线按升序定义元素。元素的参数将持续有效，直到下一个元素开始或道路参考线结束。道路的超高程程默认为零。</p><p>给定位置的超高程表达式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sElev (ds) = a + b*ds + c*ds2 + d*ds3<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>高精地图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精地图</tag>
      
      <tag>opendrive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid安装以及使用手册</title>
    <link href="/2022/08/24/02.Fluid%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2022/08/24/02.Fluid%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>方式一：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。</p><p><strong>方式二：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/fluid-dev/</span>hexo-theme-fluid.git<br></code></pre></td></tr></table></figure><p>或者直接下载压缩文件，解压后放到themes目录，将解压出来的文件夹命名为fluid</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>修改 Hexo 博客目录中的 _config.yml：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid  <span class="hljs-meta"># 指定主题</span><br><br><span class="hljs-symbol">languages:</span> <span class="hljs-built_in">zh</span>-CN  <span class="hljs-meta"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="创建页"><a href="#创建页" class="headerlink" title="创建页"></a>创建页</h2><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 layout 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020-02-23 19:20:33</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><p><strong>分类页、标签类也类似</strong></p><p>创建了这两个页，在写文章的时候，在最前面写上对应的category、tags即可</p><p>例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">使用Hexo搭建博客（基础版）</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">https://gitee.com/youlan_lan/md_image/raw/master/20210607012255.png</span><br><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">博客搭建</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">博客搭建</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">node</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">git</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">github</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">具体的参数可以查阅官方文档：</span> <span class="hljs-string">https://hexo.io/zh-cn/docs/front-matter</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂记</tag>
      
      <tag>node</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo部署以及使用手册</title>
    <link href="/2022/08/24/02.hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2022/08/24/02.hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.999.0.0&vd_source=1fd1337fa2ae0479006016eefee85a3f">参考</a></p><h2 id="hexo前期安装"><a href="#hexo前期安装" class="headerlink" title="hexo前期安装"></a>hexo前期安装</h2><ul><li>安装nodejs</li><li>安装hexo</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">node -v<span class="hljs-comment">#查看node版本</span><br><span class="hljs-built_in">npm</span> -v<span class="hljs-comment">#查看npm版本</span><br><span class="hljs-built_in">npm</span> install -g cnpm --registry=http://registry.<span class="hljs-built_in">npm</span>.taobao.org<span class="hljs-comment">#安装淘宝的cnpm 管理器</span><br>cnpm -v<span class="hljs-comment">#查看cnpm版本</span><br>cnpm install -g hexo-cli    <span class="hljs-comment">#安装hexo框架</span><br>hexo -v<span class="hljs-comment">#查看hexo版本</span><br></code></pre></td></tr></table></figure><h3 id="前期部署"><a href="#前期部署" class="headerlink" title="前期部署"></a>前期部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> blog<span class="hljs-comment">#创建blog目录</span><br><span class="hljs-built_in">cd</span> blog <span class="hljs-comment">#进入blog目录</span><br>sudo hexo init <span class="hljs-comment">#生成博客 初始化博客</span><br>hexo s<span class="hljs-comment">#启动本地博客服务</span><br>http://localhost:4000/<span class="hljs-comment">#本地访问地址</span><br></code></pre></td></tr></table></figure><p>4040不显示问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s -p 8080 <span class="hljs-comment">#换一个地址</span><br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">hexo new &quot;我的第一篇文章&quot; #创建新的文章 <br>#返回blog目录<br>hexo clean #清理<br>hexo g #生成<br>#Github创建一个新的仓库 YourGithubName.github.io<br><span class="hljs-section">cnpm install --save hexo-deployer-git #在blog目录下安装git部署插件</span><br><span class="hljs-section">----</span><br><span class="hljs-section">#配置_config.yml </span><br><span class="hljs-section">-----</span><br><span class="hljs-code"># Deployment</span><br><span class="hljs-code">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="hljs-code">deploy:</span><br><span class="hljs-code">  type: git</span><br><span class="hljs-code"> repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="hljs-section">  branch: master</span><br><span class="hljs-section">-----</span><br>hexo d#部署到Github仓库里<br>https://YourGithubName.github.io/  #访问这个地址可以查看博客<br></code></pre></td></tr></table></figure><p>hexo d 部署出现问题：</p><ol><li>需要输出用户名账号；<a href="https://blog.csdn.net/jz6666jz/article/details/105413034?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-105413034-blog-85311528.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-105413034-blog-85311528.pc_relevant_default&utm_relevant_index=2">参考</a></li><li>访问不了github（密码错误等） —- 生成token <a href="https://blog.csdn.net/weixin_42195126/article/details/123684634?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166132016616781685340991%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166132016616781685340991&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-1-123684634-null-null.142%5Ev42%5Epc_rank_34_2,185%5Ev2%5Econtrol&utm_term=hexo%20github%E5%AF%86%E7%A0%81%E8%BE%93%E5%87%BA%E9%94%99%E8%AF%AF&spm=1018.2226.3001.4187">参考</a></li></ol><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"> git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/litten/</span>hexo-theme-yilia.git themes/yilia  <span class="hljs-comment">#下载yilia主题到本地</span><br><br><span class="hljs-comment">#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</span><br></code></pre></td></tr></table></figure><h2 id="hexo基础使用"><a href="#hexo基础使用" class="headerlink" title="hexo基础使用"></a>hexo基础使用</h2><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;文章名称&quot;</span><br></code></pre></td></tr></table></figure><p>文章示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章名称</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020-02-23 19:20:33</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><p><strong>添加属性</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">使用Hexo搭建博客（基础版）</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">https://gitee.com/youlan_lan/md_image/raw/master/20210607012255.png</span><br><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">博客搭建</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">博客搭建</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">node</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">git</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">github</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="重要操作"><a href="#重要操作" class="headerlink" title="重要操作"></a>重要操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<span class="hljs-comment">#清理一下</span><br>hexo g -d<span class="hljs-comment">#生成 部署到远程Github仓库</span><br>https://YourGithubName.github.io/  <span class="hljs-comment">#查看博客</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂记</tag>
      
      <tag>node</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
